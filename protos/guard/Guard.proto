syntax = "proto3";
import "google/protobuf/timestamp.proto";



package guard;



service GuardService{
	rpc SubmitFileStoreMeta(FileStoreStatus) returns (Result);
	// rpc health() returns(HealthStatus); //used for other nodes check guard health , TBD input argument discuss with Weiyu & Jin
  	rpc SendQuestions(FileChallengeQuestions) returns(Result); //used for renter send the questions to guard
  	rpc CheckFileStoreMeta(CheckFileStoreMetaRequest) returns (FileStoreStatus); //reserved for other nodes to check contract status
}

message Log{
	google.protobuf.Timestamp change_time =1;
	bytes change_originator = 2;
	bytes change = 3;
}
//below rpc is needed for host by concept, and it work as BTFS
// service HostService{
// 	rpc challenge(ProofOfReplicateChallenge) returns (ProofOfReplicateChallenge){} //used for receieve challenge question and return the answer, TBD seems can be removed as the BTFS has embed function , no need for service
// 	rpc cancelContract(Contract) returns (Result){}  //removed for phase 2
// }

//the relationship of the objects from Guard's view
// FileStoreMeta (1:n) Contract (1:n) payout
//contract is the signed document between the renter and host for one shard's storage
// the contract information contains buyer, seller, escrow, guard , storage shard's information, rent duration, amount, payment method(periodically and times)
//ContractMeta is the information which will not be changed after proposal
//Contract technically is the contract execution record, it contains the contractMeta and state information
message ContractMeta{ //Contract proposed by renter, will not be changed after renter proposed
	bytes contract_id = 1; //one id which generated by renter, and will be check unique by escrow service
	bytes renter_address = 2; //renter's wallet address
	bytes host_address = 3; //host’s wallet address
	bytes shard_hash = 4; //shard’s hash
	int32 shard_index = 5; //shard’s sequence of the original file
	int64 shard_file_size = 6; //shard’s file size
	bytes file_hash = 7; //original file's hash, reserved point32 back to FileStoreMeta
	google.protobuf.Timestamp rent_start = 8; //rent start time
	google.protobuf.Timestamp rent_end = 9 ; //rent end time
	bytes guard_address = 10; //renter proposed guard's address
	bytes escrow_address = 11; //renter proposed escrow's address
	int64 price = 12; //the price which agreed by host and rental, on the first phase, it equal to the proposed_price
	int64 amount = 13; //the amount which agreed by host and rental, on the first phase, it should be equal file_size*duration*agreed_price
	int64 collaeteral_amount = 14; 
	enum Schedule{		
    	MONTHLY = 0;
    	QUARTERLY = 1;
    	ANNUALLY = 2;
	}
    Schedule payout_schedule = 15; // schedule for payouts
   	int32 num_payouts = 16; // numbers of payouts
}

message Contract{ //the contract executor record, changed frequently after proposal
	Contract contract = 1;
	enum ContractState{
		DRAFT = 0; //the contract was draft, but the escrow service did not received the money
		SIGNED = 1;  // the escrow service received the money from renter, the contract was start.
		UPLOADED = 2; //the first challenge was done, which means the shard was in the host, all pending payouts can be issued now
		LOST = 3; // the challenge failed, the following payout should be hold or even stopped
		CANCELED = 4; //if the shard was rebuild after LOST, or after some days of NOQUESTION, it go to CANCELED status
		CLOSED = 5; // the all work in such contract was done
	}
	ContractState state = 2;
	bytes renter_signature = 3; //renter’s signature for the sub contract
	bytes host_signature = 4; //host’s signature from the sub contract
	google.protobuf.Timestamp escrow_signed_time = 5; //contract signed time
	bytes escrow_signature = 6; //escrow's signature 
	repeated Log change_log = 7; //TBD one field to store the contract change log, need to discuss whether need the field
	google.protobuf.Timestamp last_modify_time = 8;
	bytes guard_signature = 9;
}



message FileStoreMeta{ //file store meta prepared by renter, will not changed after proposal
	bytes renter_address = 1; // buyer wallet address
	bytes file_hash = 2; // file’s hash
	int64 file_size = 3; // file’s size
	google.protobuf.Timestamp rent_start = 4; //rent start time
	google.protobuf.Timestamp rent_end = 5; //rent end time
	int32 check_frequence = 6; // shard check frequence in a year,  1 means check once per year
	int64 guard_fee= 7; // reserve: the fee which guard will charge for supporting 
	int64 escrow_fee = 8; //reserve: the fee which escrow will charge for supporting
	int32 shard_count = 9; //shard's count, by default is 30
	int32 minimum_shards = 10; //minimum count of shards which can recover the whole file, by default is 10
	int32 recover_threshold = 11; //reserved field, indicate the threshold for starting to recover
	bytes escrow_address = 12;
	bytes guard_address = 13;
}

message FileStoreStatus{
	FileStoreMeta file_store_meta = 1;
	enum MetaState{
		DRAFT = 0; //the proposal was submit by renter
		UPLOADING = 1; //all related contracts were signed, and renter is uploading shards and questions
		RUNNING = 2; //guard complete the first challenge for all shards
		PARTIAL_LOST = 3; //some shards were lost, but the whole file is safe
		LOST = 4; //some shards were lost and the whole file cannot be recovered now
		DONE = 5; //all contracts were done
	}
	MetaState state = 2;
	repeated Contract contracts = 3;
	bytes renter_signature = 4; //renter's signature for FileStoreMeta and all contractMeta
	google.protobuf.Timestamp guard_receive_time = 5; //guard received time, which used to calculate the timeout for cancel
	repeated Log change_log = 6;
	bytes guard_signature = 7;
}	

message ChallengeQuestion{
	bytes shard_hash = 1; //shard hash 
	bytes host_address = 2; //host's address
	int32 chunk_index = 3; //the chunk's index for calculation
	int32 random_nounce = 4; //the challenge questions's random nounce 
	bytes expect_answer = 5; //the challenge expected answer
}

message ProofOfReplicateChallenge{
	ChallengeQuestion question = 1; //of course expect_answer should be clear before send to the host`
	google.protobuf.Timestamp challenge_time = 2; //challenge time from guard
	bytes guard_address = 3; //guar's address
	bytes guard_signature = 4; //guard signed for the challenge
	bytes host_answer = 5; //challenge answer
	google.protobuf.Timestamp host_sign_time = 6; //response time from host
	bytes host_signature = 7;
}

message FileChallengeQuestions{
	bytes file_hash = 1;
	repeated ChallengeQuestions shard_questions = 2;
}

message ChallengeQuestions{
	bytes file_hash = 1; //file's hash
	bytes shard_hash = 2;
	bytes preparer_address = 3 ; //challenge questions preparer's address, it is renter address at phase 1
	int32 request_count = 4;
	repeated ChallengeQuestion questions= 5;
	google.protobuf.Timestamp prepare_time = 6;
	bytes renter_signature = 7;
}

message CheckFileStoreMetaRequest{
	bytes file_hash = 1;
	bytes renter_address = 2;
	bytes requester_address = 3;
	bytes signature =4; //requester signed 
}

message Result {
    enum ResponseCode {
      SUCCESS = 0;
      SIGNATURE_FORMAT_ERROR = 1;
      COMPUTE_ADDRESS_ERROR = 2;
      OTHER_ERROR = 20;
    }
    ResponseCode code = 1;
    string message = 2;
}

message HealthStatus{ 
	bytes peer_id =1; // peer ID
	bytes address = 2; // pub key/address
	enum HealthStatus{
		WRONG = 0;
		RUNNING = 1;
		BOOTSTRAP = 2; //reserve 
		PARTIAL_STOP = 3; //reserve field, some function cannot work
	}
	HealthStatus status = 3; //current status , running, starting, partial stop
	google.protobuf.Timestamp now =4; //current time of guard
	google.protobuf.Timestamp start_time = 5;
	bytes git_hash = 6; //the git hash of the build related the git repository's branch  
	bytes version = 7; //version we defined for current node
	bytes signature = 8; //signature
}




