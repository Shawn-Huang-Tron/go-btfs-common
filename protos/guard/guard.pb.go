// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: protos/guard/guard.proto

package guard

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	_ "github.com/tron-us/protobuf/gogoproto"
	proto "github.com/tron-us/protobuf/proto"
	github_com_tron_us_protobuf_types "github.com/tron-us/protobuf/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ResponseCode int32

const (
	ResponseCode_SUCCESS                ResponseCode = 0
	ResponseCode_SIGNATURE_FORMAT_ERROR ResponseCode = 1
	ResponseCode_COMPUTE_ADDRESS_ERROR  ResponseCode = 2
	ResponseCode_OTHER_ERROR            ResponseCode = 20
)

var ResponseCode_name = map[int32]string{
	0:  "SUCCESS",
	1:  "SIGNATURE_FORMAT_ERROR",
	2:  "COMPUTE_ADDRESS_ERROR",
	20: "OTHER_ERROR",
}

var ResponseCode_value = map[string]int32{
	"SUCCESS":                0,
	"SIGNATURE_FORMAT_ERROR": 1,
	"COMPUTE_ADDRESS_ERROR":  2,
	"OTHER_ERROR":            20,
}

func (x ResponseCode) String() string {
	return proto.EnumName(ResponseCode_name, int32(x))
}

func (ResponseCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{0}
}

type ContractMeta_Schedule int32

const (
	ContractMeta_MONTHLY   ContractMeta_Schedule = 0
	ContractMeta_QUARTERLY ContractMeta_Schedule = 1
	ContractMeta_ANNUALLY  ContractMeta_Schedule = 2
)

var ContractMeta_Schedule_name = map[int32]string{
	0: "MONTHLY",
	1: "QUARTERLY",
	2: "ANNUALLY",
}

var ContractMeta_Schedule_value = map[string]int32{
	"MONTHLY":   0,
	"QUARTERLY": 1,
	"ANNUALLY":  2,
}

func (x ContractMeta_Schedule) String() string {
	return proto.EnumName(ContractMeta_Schedule_name, int32(x))
}

func (ContractMeta_Schedule) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{1, 0}
}

type Contract_ContractState int32

const (
	Contract_DRAFT             Contract_ContractState = 0
	Contract_SIGNED            Contract_ContractState = 1
	Contract_UPLOADED          Contract_ContractState = 2
	Contract_LOST              Contract_ContractState = 3
	Contract_CANCELED          Contract_ContractState = 4
	Contract_CLOSED            Contract_ContractState = 5
	Contract_RENEWED           Contract_ContractState = 6
	Contract_OBSOLETE          Contract_ContractState = 7
	Contract_WARN              Contract_ContractState = 8
	Contract_DRAFT_WARN        Contract_ContractState = 9
	Contract_READY_CHALLENGE   Contract_ContractState = 10
	Contract_RECREATED         Contract_ContractState = 11
	Contract_REQUEST_CHALLENGE Contract_ContractState = 12
)

var Contract_ContractState_name = map[int32]string{
	0:  "DRAFT",
	1:  "SIGNED",
	2:  "UPLOADED",
	3:  "LOST",
	4:  "CANCELED",
	5:  "CLOSED",
	6:  "RENEWED",
	7:  "OBSOLETE",
	8:  "WARN",
	9:  "DRAFT_WARN",
	10: "READY_CHALLENGE",
	11: "RECREATED",
	12: "REQUEST_CHALLENGE",
}

var Contract_ContractState_value = map[string]int32{
	"DRAFT":             0,
	"SIGNED":            1,
	"UPLOADED":          2,
	"LOST":              3,
	"CANCELED":          4,
	"CLOSED":            5,
	"RENEWED":           6,
	"OBSOLETE":          7,
	"WARN":              8,
	"DRAFT_WARN":        9,
	"READY_CHALLENGE":   10,
	"RECREATED":         11,
	"REQUEST_CHALLENGE": 12,
}

func (x Contract_ContractState) String() string {
	return proto.EnumName(Contract_ContractState_name, int32(x))
}

func (Contract_ContractState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{2, 0}
}

type FileStoreStatus_MetaState int32

const (
	FileStoreStatus_DRAFT        FileStoreStatus_MetaState = 0
	FileStoreStatus_UPLOADING    FileStoreStatus_MetaState = 1
	FileStoreStatus_RUNNING      FileStoreStatus_MetaState = 2
	FileStoreStatus_PARTIAL_LOST FileStoreStatus_MetaState = 3
	FileStoreStatus_LOST         FileStoreStatus_MetaState = 4
	FileStoreStatus_DONE         FileStoreStatus_MetaState = 5
	FileStoreStatus_CANCELED     FileStoreStatus_MetaState = 6
	FileStoreStatus_RECREATED    FileStoreStatus_MetaState = 7
)

var FileStoreStatus_MetaState_name = map[int32]string{
	0: "DRAFT",
	1: "UPLOADING",
	2: "RUNNING",
	3: "PARTIAL_LOST",
	4: "LOST",
	5: "DONE",
	6: "CANCELED",
	7: "RECREATED",
}

var FileStoreStatus_MetaState_value = map[string]int32{
	"DRAFT":        0,
	"UPLOADING":    1,
	"RUNNING":      2,
	"PARTIAL_LOST": 3,
	"LOST":         4,
	"DONE":         5,
	"CANCELED":     6,
	"RECREATED":    7,
}

func (x FileStoreStatus_MetaState) String() string {
	return proto.EnumName(FileStoreStatus_MetaState_name, int32(x))
}

func (FileStoreStatus_MetaState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{5, 0}
}

type FileStoreStatus_RentalState int32

const (
	FileStoreStatus_NEW         FileStoreStatus_RentalState = 0
	FileStoreStatus_PARTIAL_NEW FileStoreStatus_RentalState = 1
	FileStoreStatus_EXPIRED     FileStoreStatus_RentalState = 2
	FileStoreStatus_RENEW       FileStoreStatus_RentalState = 3
	FileStoreStatus_RECREATE    FileStoreStatus_RentalState = 4
)

var FileStoreStatus_RentalState_name = map[int32]string{
	0: "NEW",
	1: "PARTIAL_NEW",
	2: "EXPIRED",
	3: "RENEW",
	4: "RECREATE",
}

var FileStoreStatus_RentalState_value = map[string]int32{
	"NEW":         0,
	"PARTIAL_NEW": 1,
	"EXPIRED":     2,
	"RENEW":       3,
	"RECREATE":    4,
}

func (x FileStoreStatus_RentalState) String() string {
	return proto.EnumName(FileStoreStatus_RentalState_name, int32(x))
}

func (FileStoreStatus_RentalState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{5, 1}
}

type ListHostContractsRequest_SelectState int32

const (
	ListHostContractsRequest_ALL    ListHostContractsRequest_SelectState = 0
	ListHostContractsRequest_ACTIVE ListHostContractsRequest_SelectState = 1
	ListHostContractsRequest_CLOSED ListHostContractsRequest_SelectState = 2
)

var ListHostContractsRequest_SelectState_name = map[int32]string{
	0: "ALL",
	1: "ACTIVE",
	2: "CLOSED",
}

var ListHostContractsRequest_SelectState_value = map[string]int32{
	"ALL":    0,
	"ACTIVE": 1,
	"CLOSED": 2,
}

func (x ListHostContractsRequest_SelectState) String() string {
	return proto.EnumName(ListHostContractsRequest_SelectState_name, int32(x))
}

func (ListHostContractsRequest_SelectState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{12, 0}
}

type RepairContractResponse_ContractResponseStatus int32

const (
	RepairContractResponse_BOTH_SIGNED RepairContractResponse_ContractResponseStatus = 0
	RepairContractResponse_WAIT_LIST   RepairContractResponse_ContractResponseStatus = 1
	RepairContractResponse_REJECTED    RepairContractResponse_ContractResponseStatus = 2
)

var RepairContractResponse_ContractResponseStatus_name = map[int32]string{
	0: "BOTH_SIGNED",
	1: "WAIT_LIST",
	2: "REJECTED",
}

var RepairContractResponse_ContractResponseStatus_value = map[string]int32{
	"BOTH_SIGNED": 0,
	"WAIT_LIST":   1,
	"REJECTED":    2,
}

func (x RepairContractResponse_ContractResponseStatus) String() string {
	return proto.EnumName(RepairContractResponse_ContractResponseStatus_name, int32(x))
}

func (RepairContractResponse_ContractResponseStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{20, 0}
}

type ResponseRepairContracts_RepairStat int32

const (
	ResponseRepairContracts_CONTRACT_READY    ResponseRepairContracts_RepairStat = 0
	ResponseRepairContracts_DOWNLOAD_NOT_DONE ResponseRepairContracts_RepairStat = 1
	ResponseRepairContracts_REQUEST_AGAIN     ResponseRepairContracts_RepairStat = 2
	ResponseRepairContracts_CONTRACT_CLOSED   ResponseRepairContracts_RepairStat = 3
)

var ResponseRepairContracts_RepairStat_name = map[int32]string{
	0: "CONTRACT_READY",
	1: "DOWNLOAD_NOT_DONE",
	2: "REQUEST_AGAIN",
	3: "CONTRACT_CLOSED",
}

var ResponseRepairContracts_RepairStat_value = map[string]int32{
	"CONTRACT_READY":    0,
	"DOWNLOAD_NOT_DONE": 1,
	"REQUEST_AGAIN":     2,
	"CONTRACT_CLOSED":   3,
}

func (x ResponseRepairContracts_RepairStat) String() string {
	return proto.EnumName(ResponseRepairContracts_RepairStat_name, int32(x))
}

func (ResponseRepairContracts_RepairStat) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{22, 0}
}

type Log struct {
	ChangeTime           time.Time `protobuf:"bytes,1,opt,name=change_time,json=changeTime,proto3,stdtime" json:"change_time" pg:"change_time"`
	OriginatorPid        string    `protobuf:"bytes,2,opt,name=originator_pid,json=originatorPid,proto3" json:"originator_pid,omitempty" pg:"originator_pid"`
	Change               string    `protobuf:"bytes,3,opt,name=change,proto3" json:"change,omitempty" pg:"change"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-" pg:"-"`
	XXX_unrecognized     []byte    `json:"-" pg:"-"`
	XXX_sizecache        int32     `json:"-" pg:"-"`
}

func (m *Log) Reset()         { *m = Log{} }
func (m *Log) String() string { return proto.CompactTextString(m) }
func (*Log) ProtoMessage()    {}
func (*Log) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{0}
}
func (m *Log) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Log) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Log.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Log) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Log.Merge(m, src)
}
func (m *Log) XXX_Size() int {
	return m.Size()
}
func (m *Log) XXX_DiscardUnknown() {
	xxx_messageInfo_Log.DiscardUnknown(m)
}

var xxx_messageInfo_Log proto.InternalMessageInfo

func (m *Log) GetChangeTime() time.Time {
	if m != nil {
		return m.ChangeTime
	}
	return time.Time{}
}

func (m *Log) GetOriginatorPid() string {
	if m != nil {
		return m.OriginatorPid
	}
	return ""
}

func (m *Log) GetChange() string {
	if m != nil {
		return m.Change
	}
	return ""
}

func (*Log) XXX_MessageName() string {
	return "guard.Log"
}

//the relationship of the objects from Guard's view
// FileStoreMeta (1:n) Contract (1:n) payout
//contract is the signed document between the renter and host for one shard's storage
// the contract information contains buyer, seller, escrow, guard , storage shard's information, rent duration, amount, payment method(periodically and times)
//ContractMeta is the information which will not be changed after proposal
//Contract technically is the contract execution record, it contains the contractMeta and state information
type ContractMeta struct {
	//Contract proposed by renter, will not be changed after renter proposed
	ContractId           string                `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty" pg:"contract_id"`
	RenterPid            string                `protobuf:"bytes,2,opt,name=renter_pid,json=renterPid,proto3" json:"renter_pid,omitempty" pg:"renter_pid"`
	HostPid              string                `protobuf:"bytes,3,opt,name=host_pid,json=hostPid,proto3" json:"host_pid,omitempty" pg:"host_pid"`
	ShardHash            string                `protobuf:"bytes,4,opt,name=shard_hash,json=shardHash,proto3" json:"shard_hash,omitempty" pg:"shard_hash"`
	ShardIndex           int32                 `protobuf:"varint,5,opt,name=shard_index,json=shardIndex,proto3" json:"shard_index,omitempty" pg:"shard_index"`
	ShardFileSize        int64                 `protobuf:"varint,6,opt,name=shard_file_size,json=shardFileSize,proto3" json:"shard_file_size,omitempty" pg:"shard_file_size"`
	FileHash             string                `protobuf:"bytes,7,opt,name=file_hash,json=fileHash,proto3" json:"file_hash,omitempty" pg:"file_hash"`
	RentStart            time.Time             `protobuf:"bytes,8,opt,name=rent_start,json=rentStart,proto3,stdtime" json:"rent_start" pg:"rent_start"`
	RentEnd              time.Time             `protobuf:"bytes,9,opt,name=rent_end,json=rentEnd,proto3,stdtime" json:"rent_end" pg:"rent_end"`
	GuardPid             string                `protobuf:"bytes,10,opt,name=guard_pid,json=guardPid,proto3" json:"guard_pid,omitempty" pg:"guard_pid"`
	EscrowPid            string                `protobuf:"bytes,11,opt,name=escrow_pid,json=escrowPid,proto3" json:"escrow_pid,omitempty" pg:"escrow_pid"`
	Price                int64                 `protobuf:"varint,12,opt,name=price,proto3" json:"price,omitempty" pg:"price"`
	Amount               int64                 `protobuf:"varint,13,opt,name=amount,proto3" json:"amount,omitempty" pg:"amount"`
	CollateralAmount     int64                 `protobuf:"varint,14,opt,name=collateral_amount,json=collateralAmount,proto3" json:"collateral_amount,omitempty" pg:"collateral_amount"`
	PayoutSchedule       ContractMeta_Schedule `protobuf:"varint,15,opt,name=payout_schedule,json=payoutSchedule,proto3,enum=guard.ContractMeta_Schedule" json:"payout_schedule,omitempty" pg:"payout_schedule"`
	NumPayouts           int32                 `protobuf:"varint,16,opt,name=num_payouts,json=numPayouts,proto3" json:"num_payouts,omitempty" pg:"num_payouts"`
	ContingentAmount     int64                 `protobuf:"varint,17,opt,name=contingent_amount,json=contingentAmount,proto3" json:"contingent_amount,omitempty" pg:"contingent_amount"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-" pg:"-"`
	XXX_unrecognized     []byte                `json:"-" pg:"-"`
	XXX_sizecache        int32                 `json:"-" pg:"-"`
}

func (m *ContractMeta) Reset()         { *m = ContractMeta{} }
func (m *ContractMeta) String() string { return proto.CompactTextString(m) }
func (*ContractMeta) ProtoMessage()    {}
func (*ContractMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{1}
}
func (m *ContractMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContractMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContractMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContractMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContractMeta.Merge(m, src)
}
func (m *ContractMeta) XXX_Size() int {
	return m.Size()
}
func (m *ContractMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_ContractMeta.DiscardUnknown(m)
}

var xxx_messageInfo_ContractMeta proto.InternalMessageInfo

func (m *ContractMeta) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *ContractMeta) GetRenterPid() string {
	if m != nil {
		return m.RenterPid
	}
	return ""
}

func (m *ContractMeta) GetHostPid() string {
	if m != nil {
		return m.HostPid
	}
	return ""
}

func (m *ContractMeta) GetShardHash() string {
	if m != nil {
		return m.ShardHash
	}
	return ""
}

func (m *ContractMeta) GetShardIndex() int32 {
	if m != nil {
		return m.ShardIndex
	}
	return 0
}

func (m *ContractMeta) GetShardFileSize() int64 {
	if m != nil {
		return m.ShardFileSize
	}
	return 0
}

func (m *ContractMeta) GetFileHash() string {
	if m != nil {
		return m.FileHash
	}
	return ""
}

func (m *ContractMeta) GetRentStart() time.Time {
	if m != nil {
		return m.RentStart
	}
	return time.Time{}
}

func (m *ContractMeta) GetRentEnd() time.Time {
	if m != nil {
		return m.RentEnd
	}
	return time.Time{}
}

func (m *ContractMeta) GetGuardPid() string {
	if m != nil {
		return m.GuardPid
	}
	return ""
}

func (m *ContractMeta) GetEscrowPid() string {
	if m != nil {
		return m.EscrowPid
	}
	return ""
}

func (m *ContractMeta) GetPrice() int64 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *ContractMeta) GetAmount() int64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *ContractMeta) GetCollateralAmount() int64 {
	if m != nil {
		return m.CollateralAmount
	}
	return 0
}

func (m *ContractMeta) GetPayoutSchedule() ContractMeta_Schedule {
	if m != nil {
		return m.PayoutSchedule
	}
	return ContractMeta_MONTHLY
}

func (m *ContractMeta) GetNumPayouts() int32 {
	if m != nil {
		return m.NumPayouts
	}
	return 0
}

func (m *ContractMeta) GetContingentAmount() int64 {
	if m != nil {
		return m.ContingentAmount
	}
	return 0
}

func (*ContractMeta) XXX_MessageName() string {
	return "guard.ContractMeta"
}

type Contract struct {
	//the contract executor record, changed frequently after proposal
	ContractMeta             `protobuf:"bytes,1,opt,name=contract,proto3,embedded=contract" json:"contract" pg:"contract"`
	State                    Contract_ContractState `protobuf:"varint,2,opt,name=state,proto3,enum=guard.Contract_ContractState" json:"state,omitempty" pg:"state"`
	RenterSignature          []byte                 `protobuf:"bytes,3,opt,name=renter_signature,json=renterSignature,proto3" json:"renter_signature,omitempty" pg:"renter_signature"`
	HostSignature            []byte                 `protobuf:"bytes,4,opt,name=host_signature,json=hostSignature,proto3" json:"host_signature,omitempty" pg:"host_signature"`
	EscrowSignedTime         time.Time              `protobuf:"bytes,5,opt,name=escrow_signed_time,json=escrowSignedTime,proto3,stdtime" json:"escrow_signed_time" pg:"escrow_signed_time"`
	EscrowSignature          []byte                 `protobuf:"bytes,6,opt,name=escrow_signature,json=escrowSignature,proto3" json:"escrow_signature,omitempty" pg:"escrow_signature"`
	ChangeLog                []*Log                 `protobuf:"bytes,7,rep,name=change_log,json=changeLog,proto3" json:"change_log,omitempty" pg:"-"`
	LastModifyTime           time.Time              `protobuf:"bytes,8,opt,name=last_modify_time,json=lastModifyTime,proto3,stdtime" json:"last_modify_time" pg:"last_modify_time"`
	GuardSignature           []byte                 `protobuf:"bytes,9,opt,name=guard_signature,json=guardSignature,proto3" json:"guard_signature,omitempty" pg:"guard_signature"`
	PreparerPid              string                 `protobuf:"bytes,10,opt,name=preparer_pid,json=preparerPid,proto3" json:"preparer_pid,omitempty" pg:"preparer_pid"`
	PreparerSignature        []byte                 `protobuf:"bytes,11,opt,name=preparer_signature,json=preparerSignature,proto3" json:"preparer_signature,omitempty" pg:"preparer_signature"`
	LastSuccessChallengeTime time.Time              `protobuf:"bytes,12,opt,name=last_success_challenge_time,json=lastSuccessChallengeTime,proto3,stdtime" json:"last_success_challenge_time" pg:"last_success_challenge_time"`
	LastChallengeTime        time.Time              `protobuf:"bytes,13,opt,name=last_challenge_time,json=lastChallengeTime,proto3,stdtime" json:"last_challenge_time" pg:"last_challenge_time"`
	ChallengeTimes           int32                  `protobuf:"varint,14,opt,name=challenge_times,json=challengeTimes,proto3" json:"challenge_times,omitempty" pg:"challenge_times"`
	ChallengeWarnTimes       int32                  `protobuf:"varint,15,opt,name=challenge_warn_times,json=challengeWarnTimes,proto3" json:"challenge_warn_times,omitempty" pg:"challenge_warn_times"`
	ChallengeSuccessTimes    int32                  `protobuf:"varint,16,opt,name=challenge_success_times,json=challengeSuccessTimes,proto3" json:"challenge_success_times,omitempty" pg:"challenge_success_times"`
	FirstChallengeSuccess    time.Time              `protobuf:"bytes,17,opt,name=first_challenge_success,json=firstChallengeSuccess,proto3,stdtime" json:"first_challenge_success" pg:"first_challenge_success"`
	XXX_NoUnkeyedLiteral     struct{}               `json:"-" pg:"-"`
	XXX_unrecognized         []byte                 `json:"-" pg:"-"`
	XXX_sizecache            int32                  `json:"-" pg:"-"`
}

func (m *Contract) Reset()         { *m = Contract{} }
func (m *Contract) String() string { return proto.CompactTextString(m) }
func (*Contract) ProtoMessage()    {}
func (*Contract) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{2}
}
func (m *Contract) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Contract) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Contract.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Contract) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Contract.Merge(m, src)
}
func (m *Contract) XXX_Size() int {
	return m.Size()
}
func (m *Contract) XXX_DiscardUnknown() {
	xxx_messageInfo_Contract.DiscardUnknown(m)
}

var xxx_messageInfo_Contract proto.InternalMessageInfo

func (m *Contract) GetState() Contract_ContractState {
	if m != nil {
		return m.State
	}
	return Contract_DRAFT
}

func (m *Contract) GetRenterSignature() []byte {
	if m != nil {
		return m.RenterSignature
	}
	return nil
}

func (m *Contract) GetHostSignature() []byte {
	if m != nil {
		return m.HostSignature
	}
	return nil
}

func (m *Contract) GetEscrowSignedTime() time.Time {
	if m != nil {
		return m.EscrowSignedTime
	}
	return time.Time{}
}

func (m *Contract) GetEscrowSignature() []byte {
	if m != nil {
		return m.EscrowSignature
	}
	return nil
}

func (m *Contract) GetChangeLog() []*Log {
	if m != nil {
		return m.ChangeLog
	}
	return nil
}

func (m *Contract) GetLastModifyTime() time.Time {
	if m != nil {
		return m.LastModifyTime
	}
	return time.Time{}
}

func (m *Contract) GetGuardSignature() []byte {
	if m != nil {
		return m.GuardSignature
	}
	return nil
}

func (m *Contract) GetPreparerPid() string {
	if m != nil {
		return m.PreparerPid
	}
	return ""
}

func (m *Contract) GetPreparerSignature() []byte {
	if m != nil {
		return m.PreparerSignature
	}
	return nil
}

func (m *Contract) GetLastSuccessChallengeTime() time.Time {
	if m != nil {
		return m.LastSuccessChallengeTime
	}
	return time.Time{}
}

func (m *Contract) GetLastChallengeTime() time.Time {
	if m != nil {
		return m.LastChallengeTime
	}
	return time.Time{}
}

func (m *Contract) GetChallengeTimes() int32 {
	if m != nil {
		return m.ChallengeTimes
	}
	return 0
}

func (m *Contract) GetChallengeWarnTimes() int32 {
	if m != nil {
		return m.ChallengeWarnTimes
	}
	return 0
}

func (m *Contract) GetChallengeSuccessTimes() int32 {
	if m != nil {
		return m.ChallengeSuccessTimes
	}
	return 0
}

func (m *Contract) GetFirstChallengeSuccess() time.Time {
	if m != nil {
		return m.FirstChallengeSuccess
	}
	return time.Time{}
}

func (*Contract) XXX_MessageName() string {
	return "guard.Contract"
}

type FileStoreListResponse struct {
	Request              *ListRenterFileInfoRequest `protobuf:"bytes,1,opt,name=request,proto3" json:"request,omitempty" pg:"request"`
	CurrentTime          time.Time                  `protobuf:"bytes,2,opt,name=current_time,json=currentTime,proto3,stdtime" json:"current_time" pg:"current_time"`
	FileStoreMeta        []*FileStoreMeta           `protobuf:"bytes,3,rep,name=file_store_meta,json=fileStoreMeta,proto3" json:"file_store_meta,omitempty" pg:"file_store_meta"`
	Count                int32                      `protobuf:"varint,4,opt,name=count,proto3" json:"count,omitempty" pg:"count"`
	Signature            []byte                     `protobuf:"bytes,5,opt,name=signature,proto3" json:"signature,omitempty" pg:"signature"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-" pg:"-"`
	XXX_unrecognized     []byte                     `json:"-" pg:"-"`
	XXX_sizecache        int32                      `json:"-" pg:"-"`
}

func (m *FileStoreListResponse) Reset()         { *m = FileStoreListResponse{} }
func (m *FileStoreListResponse) String() string { return proto.CompactTextString(m) }
func (*FileStoreListResponse) ProtoMessage()    {}
func (*FileStoreListResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{3}
}
func (m *FileStoreListResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileStoreListResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileStoreListResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileStoreListResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileStoreListResponse.Merge(m, src)
}
func (m *FileStoreListResponse) XXX_Size() int {
	return m.Size()
}
func (m *FileStoreListResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FileStoreListResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FileStoreListResponse proto.InternalMessageInfo

func (m *FileStoreListResponse) GetRequest() *ListRenterFileInfoRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *FileStoreListResponse) GetCurrentTime() time.Time {
	if m != nil {
		return m.CurrentTime
	}
	return time.Time{}
}

func (m *FileStoreListResponse) GetFileStoreMeta() []*FileStoreMeta {
	if m != nil {
		return m.FileStoreMeta
	}
	return nil
}

func (m *FileStoreListResponse) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *FileStoreListResponse) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (*FileStoreListResponse) XXX_MessageName() string {
	return "guard.FileStoreListResponse"
}

type FileStoreMeta struct {
	//file store meta prepared by renter, will not changed after proposal
	RenterPid                  string    `protobuf:"bytes,1,opt,name=renter_pid,json=renterPid,proto3" json:"renter_pid,omitempty" pg:"renter_pid"`
	FileHash                   string    `protobuf:"bytes,2,opt,name=file_hash,json=fileHash,proto3" json:"file_hash,omitempty" pg:"file_hash"`
	FileSize                   int64     `protobuf:"varint,3,opt,name=file_size,json=fileSize,proto3" json:"file_size,omitempty" pg:"file_size"`
	RentStart                  time.Time `protobuf:"bytes,4,opt,name=rent_start,json=rentStart,proto3,stdtime" json:"rent_start" pg:"rent_start"`
	RentEnd                    time.Time `protobuf:"bytes,5,opt,name=rent_end,json=rentEnd,proto3,stdtime" json:"rent_end" pg:"rent_end"`
	CheckFrequency             int32     `protobuf:"varint,6,opt,name=check_frequency,json=checkFrequency,proto3" json:"check_frequency,omitempty" pg:"check_frequency"`
	GuardFee                   int64     `protobuf:"varint,7,opt,name=guard_fee,json=guardFee,proto3" json:"guard_fee,omitempty" pg:"guard_fee"`
	EscrowFee                  int64     `protobuf:"varint,8,opt,name=escrow_fee,json=escrowFee,proto3" json:"escrow_fee,omitempty" pg:"escrow_fee"`
	ShardCount                 int32     `protobuf:"varint,9,opt,name=shard_count,json=shardCount,proto3" json:"shard_count,omitempty" pg:"shard_count"`
	MinimumShards              int32     `protobuf:"varint,10,opt,name=minimum_shards,json=minimumShards,proto3" json:"minimum_shards,omitempty" pg:"minimum_shards"`
	RecoverThreshold           int32     `protobuf:"varint,11,opt,name=recover_threshold,json=recoverThreshold,proto3" json:"recover_threshold,omitempty" pg:"recover_threshold"`
	EscrowPid                  string    `protobuf:"bytes,12,opt,name=escrow_pid,json=escrowPid,proto3" json:"escrow_pid,omitempty" pg:"escrow_pid"`
	GuardPid                   string    `protobuf:"bytes,13,opt,name=guard_pid,json=guardPid,proto3" json:"guard_pid,omitempty" pg:"guard_pid"`
	WarnChallengeTimesLimit    int32     `protobuf:"varint,14,opt,name=warn_challenge_times_limit,json=warnChallengeTimesLimit,proto3" json:"warn_challenge_times_limit,omitempty" pg:"warn_challenge_times_limit"`
	SuccessChallengeTimesLimit int32     `protobuf:"varint,15,opt,name=success_challenge_times_limit,json=successChallengeTimesLimit,proto3" json:"success_challenge_times_limit,omitempty" pg:"success_challenge_times_limit"`
	CheckFrequencyWarn         int32     `protobuf:"varint,16,opt,name=check_frequency_warn,json=checkFrequencyWarn,proto3" json:"check_frequency_warn,omitempty" pg:"check_frequency_warn"`
	XXX_NoUnkeyedLiteral       struct{}  `json:"-" pg:"-"`
	XXX_unrecognized           []byte    `json:"-" pg:"-"`
	XXX_sizecache              int32     `json:"-" pg:"-"`
}

func (m *FileStoreMeta) Reset()         { *m = FileStoreMeta{} }
func (m *FileStoreMeta) String() string { return proto.CompactTextString(m) }
func (*FileStoreMeta) ProtoMessage()    {}
func (*FileStoreMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{4}
}
func (m *FileStoreMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileStoreMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileStoreMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileStoreMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileStoreMeta.Merge(m, src)
}
func (m *FileStoreMeta) XXX_Size() int {
	return m.Size()
}
func (m *FileStoreMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_FileStoreMeta.DiscardUnknown(m)
}

var xxx_messageInfo_FileStoreMeta proto.InternalMessageInfo

func (m *FileStoreMeta) GetRenterPid() string {
	if m != nil {
		return m.RenterPid
	}
	return ""
}

func (m *FileStoreMeta) GetFileHash() string {
	if m != nil {
		return m.FileHash
	}
	return ""
}

func (m *FileStoreMeta) GetFileSize() int64 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

func (m *FileStoreMeta) GetRentStart() time.Time {
	if m != nil {
		return m.RentStart
	}
	return time.Time{}
}

func (m *FileStoreMeta) GetRentEnd() time.Time {
	if m != nil {
		return m.RentEnd
	}
	return time.Time{}
}

func (m *FileStoreMeta) GetCheckFrequency() int32 {
	if m != nil {
		return m.CheckFrequency
	}
	return 0
}

func (m *FileStoreMeta) GetGuardFee() int64 {
	if m != nil {
		return m.GuardFee
	}
	return 0
}

func (m *FileStoreMeta) GetEscrowFee() int64 {
	if m != nil {
		return m.EscrowFee
	}
	return 0
}

func (m *FileStoreMeta) GetShardCount() int32 {
	if m != nil {
		return m.ShardCount
	}
	return 0
}

func (m *FileStoreMeta) GetMinimumShards() int32 {
	if m != nil {
		return m.MinimumShards
	}
	return 0
}

func (m *FileStoreMeta) GetRecoverThreshold() int32 {
	if m != nil {
		return m.RecoverThreshold
	}
	return 0
}

func (m *FileStoreMeta) GetEscrowPid() string {
	if m != nil {
		return m.EscrowPid
	}
	return ""
}

func (m *FileStoreMeta) GetGuardPid() string {
	if m != nil {
		return m.GuardPid
	}
	return ""
}

func (m *FileStoreMeta) GetWarnChallengeTimesLimit() int32 {
	if m != nil {
		return m.WarnChallengeTimesLimit
	}
	return 0
}

func (m *FileStoreMeta) GetSuccessChallengeTimesLimit() int32 {
	if m != nil {
		return m.SuccessChallengeTimesLimit
	}
	return 0
}

func (m *FileStoreMeta) GetCheckFrequencyWarn() int32 {
	if m != nil {
		return m.CheckFrequencyWarn
	}
	return 0
}

func (*FileStoreMeta) XXX_MessageName() string {
	return "guard.FileStoreMeta"
}

type FileStoreStatus struct {
	FileStoreMeta        `protobuf:"bytes,1,opt,name=file_store_meta,json=fileStoreMeta,proto3,embedded=file_store_meta" json:"file_store_meta" pg:"file_store_meta"`
	State                FileStoreStatus_MetaState   `protobuf:"varint,2,opt,name=state,proto3,enum=guard.FileStoreStatus_MetaState" json:"state,omitempty" pg:"state"`
	Contracts            []*Contract                 `protobuf:"bytes,3,rep,name=contracts,proto3" json:"contracts,omitempty" pg:"-"`
	RenterSignature      []byte                      `protobuf:"bytes,4,opt,name=renter_signature,json=renterSignature,proto3" json:"renter_signature,omitempty" pg:"renter_signature"`
	GuardReceiveTime     time.Time                   `protobuf:"bytes,5,opt,name=guard_receive_time,json=guardReceiveTime,proto3,stdtime" json:"guard_receive_time" pg:"guard_receive_time"`
	ChangeLog            []*Log                      `protobuf:"bytes,6,rep,name=change_log,json=changeLog,proto3" json:"change_log,omitempty" pg:"-"`
	CurrentTime          time.Time                   `protobuf:"bytes,7,opt,name=current_time,json=currentTime,proto3,stdtime" json:"current_time" pg:"current_time"`
	GuardSignature       []byte                      `protobuf:"bytes,8,opt,name=guard_signature,json=guardSignature,proto3" json:"guard_signature,omitempty" pg:"guard_signature"`
	RentalState          FileStoreStatus_RentalState `protobuf:"varint,9,opt,name=rental_state,json=rentalState,proto3,enum=guard.FileStoreStatus_RentalState" json:"rental_state,omitempty" pg:"rental_state"`
	PreparerPid          string                      `protobuf:"bytes,10,opt,name=preparer_pid,json=preparerPid,proto3" json:"preparer_pid,omitempty" pg:"preparer_pid"`
	PreparerSignature    []byte                      `protobuf:"bytes,11,opt,name=preparer_signature,json=preparerSignature,proto3" json:"preparer_signature,omitempty" pg:"preparer_signature"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-" pg:"-"`
	XXX_unrecognized     []byte                      `json:"-" pg:"-"`
	XXX_sizecache        int32                       `json:"-" pg:"-"`
}

func (m *FileStoreStatus) Reset()         { *m = FileStoreStatus{} }
func (m *FileStoreStatus) String() string { return proto.CompactTextString(m) }
func (*FileStoreStatus) ProtoMessage()    {}
func (*FileStoreStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{5}
}
func (m *FileStoreStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileStoreStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileStoreStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileStoreStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileStoreStatus.Merge(m, src)
}
func (m *FileStoreStatus) XXX_Size() int {
	return m.Size()
}
func (m *FileStoreStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_FileStoreStatus.DiscardUnknown(m)
}

var xxx_messageInfo_FileStoreStatus proto.InternalMessageInfo

func (m *FileStoreStatus) GetState() FileStoreStatus_MetaState {
	if m != nil {
		return m.State
	}
	return FileStoreStatus_DRAFT
}

func (m *FileStoreStatus) GetContracts() []*Contract {
	if m != nil {
		return m.Contracts
	}
	return nil
}

func (m *FileStoreStatus) GetRenterSignature() []byte {
	if m != nil {
		return m.RenterSignature
	}
	return nil
}

func (m *FileStoreStatus) GetGuardReceiveTime() time.Time {
	if m != nil {
		return m.GuardReceiveTime
	}
	return time.Time{}
}

func (m *FileStoreStatus) GetChangeLog() []*Log {
	if m != nil {
		return m.ChangeLog
	}
	return nil
}

func (m *FileStoreStatus) GetCurrentTime() time.Time {
	if m != nil {
		return m.CurrentTime
	}
	return time.Time{}
}

func (m *FileStoreStatus) GetGuardSignature() []byte {
	if m != nil {
		return m.GuardSignature
	}
	return nil
}

func (m *FileStoreStatus) GetRentalState() FileStoreStatus_RentalState {
	if m != nil {
		return m.RentalState
	}
	return FileStoreStatus_NEW
}

func (m *FileStoreStatus) GetPreparerPid() string {
	if m != nil {
		return m.PreparerPid
	}
	return ""
}

func (m *FileStoreStatus) GetPreparerSignature() []byte {
	if m != nil {
		return m.PreparerSignature
	}
	return nil
}

func (*FileStoreStatus) XXX_MessageName() string {
	return "guard.FileStoreStatus"
}

type ChallengeQuestion struct {
	ShardHash            string   `protobuf:"bytes,1,opt,name=shard_hash,json=shardHash,proto3" json:"shard_hash,omitempty" pg:"shard_hash"`
	HostPid              string   `protobuf:"bytes,2,opt,name=host_pid,json=hostPid,proto3" json:"host_pid,omitempty" pg:"host_pid"`
	ChunkIndex           int32    `protobuf:"varint,3,opt,name=chunk_index,json=chunkIndex,proto3" json:"chunk_index,omitempty" pg:"chunk_index"`
	Nonce                string   `protobuf:"bytes,4,opt,name=nonce,proto3" json:"nonce,omitempty" pg:"nonce"`
	ExpectAnswer         string   `protobuf:"bytes,5,opt,name=expect_answer,json=expectAnswer,proto3" json:"expect_answer,omitempty" pg:"expect_answer"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" pg:"-"`
	XXX_unrecognized     []byte   `json:"-" pg:"-"`
	XXX_sizecache        int32    `json:"-" pg:"-"`
}

func (m *ChallengeQuestion) Reset()         { *m = ChallengeQuestion{} }
func (m *ChallengeQuestion) String() string { return proto.CompactTextString(m) }
func (*ChallengeQuestion) ProtoMessage()    {}
func (*ChallengeQuestion) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{6}
}
func (m *ChallengeQuestion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChallengeQuestion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChallengeQuestion.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChallengeQuestion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChallengeQuestion.Merge(m, src)
}
func (m *ChallengeQuestion) XXX_Size() int {
	return m.Size()
}
func (m *ChallengeQuestion) XXX_DiscardUnknown() {
	xxx_messageInfo_ChallengeQuestion.DiscardUnknown(m)
}

var xxx_messageInfo_ChallengeQuestion proto.InternalMessageInfo

func (m *ChallengeQuestion) GetShardHash() string {
	if m != nil {
		return m.ShardHash
	}
	return ""
}

func (m *ChallengeQuestion) GetHostPid() string {
	if m != nil {
		return m.HostPid
	}
	return ""
}

func (m *ChallengeQuestion) GetChunkIndex() int32 {
	if m != nil {
		return m.ChunkIndex
	}
	return 0
}

func (m *ChallengeQuestion) GetNonce() string {
	if m != nil {
		return m.Nonce
	}
	return ""
}

func (m *ChallengeQuestion) GetExpectAnswer() string {
	if m != nil {
		return m.ExpectAnswer
	}
	return ""
}

func (*ChallengeQuestion) XXX_MessageName() string {
	return "guard.ChallengeQuestion"
}

type ProofOfReplicateChallenge struct {
	ChallengeQuestion    `protobuf:"bytes,1,opt,name=question,proto3,embedded=question" json:"question" pg:"question"`
	ChallengeTime        time.Time `protobuf:"bytes,2,opt,name=challenge_time,json=challengeTime,proto3,stdtime" json:"challenge_time" pg:"challenge_time"`
	GuardPid             string    `protobuf:"bytes,3,opt,name=guard_pid,json=guardPid,proto3" json:"guard_pid,omitempty" pg:"guard_pid"`
	GuardSignature       []byte    `protobuf:"bytes,4,opt,name=guard_signature,json=guardSignature,proto3" json:"guard_signature,omitempty" pg:"guard_signature"`
	HostAnswer           string    `protobuf:"bytes,5,opt,name=host_answer,json=hostAnswer,proto3" json:"host_answer,omitempty" pg:"host_answer"`
	HostSignTime         time.Time `protobuf:"bytes,6,opt,name=host_sign_time,json=hostSignTime,proto3,stdtime" json:"host_sign_time" pg:"host_sign_time"`
	HostSignature        []byte    `protobuf:"bytes,7,opt,name=host_signature,json=hostSignature,proto3" json:"host_signature,omitempty" pg:"host_signature"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-" pg:"-"`
	XXX_unrecognized     []byte    `json:"-" pg:"-"`
	XXX_sizecache        int32     `json:"-" pg:"-"`
}

func (m *ProofOfReplicateChallenge) Reset()         { *m = ProofOfReplicateChallenge{} }
func (m *ProofOfReplicateChallenge) String() string { return proto.CompactTextString(m) }
func (*ProofOfReplicateChallenge) ProtoMessage()    {}
func (*ProofOfReplicateChallenge) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{7}
}
func (m *ProofOfReplicateChallenge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProofOfReplicateChallenge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProofOfReplicateChallenge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProofOfReplicateChallenge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProofOfReplicateChallenge.Merge(m, src)
}
func (m *ProofOfReplicateChallenge) XXX_Size() int {
	return m.Size()
}
func (m *ProofOfReplicateChallenge) XXX_DiscardUnknown() {
	xxx_messageInfo_ProofOfReplicateChallenge.DiscardUnknown(m)
}

var xxx_messageInfo_ProofOfReplicateChallenge proto.InternalMessageInfo

func (m *ProofOfReplicateChallenge) GetChallengeTime() time.Time {
	if m != nil {
		return m.ChallengeTime
	}
	return time.Time{}
}

func (m *ProofOfReplicateChallenge) GetGuardPid() string {
	if m != nil {
		return m.GuardPid
	}
	return ""
}

func (m *ProofOfReplicateChallenge) GetGuardSignature() []byte {
	if m != nil {
		return m.GuardSignature
	}
	return nil
}

func (m *ProofOfReplicateChallenge) GetHostAnswer() string {
	if m != nil {
		return m.HostAnswer
	}
	return ""
}

func (m *ProofOfReplicateChallenge) GetHostSignTime() time.Time {
	if m != nil {
		return m.HostSignTime
	}
	return time.Time{}
}

func (m *ProofOfReplicateChallenge) GetHostSignature() []byte {
	if m != nil {
		return m.HostSignature
	}
	return nil
}

func (*ProofOfReplicateChallenge) XXX_MessageName() string {
	return "guard.ProofOfReplicateChallenge"
}

type FileChallengeQuestions struct {
	FileHash             string                     `protobuf:"bytes,1,opt,name=file_hash,json=fileHash,proto3" json:"file_hash,omitempty" pg:"file_hash"`
	ShardQuestions       []*ShardChallengeQuestions `protobuf:"bytes,2,rep,name=shard_questions,json=shardQuestions,proto3" json:"shard_questions,omitempty" pg:"shard_questions"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-" pg:"-"`
	XXX_unrecognized     []byte                     `json:"-" pg:"-"`
	XXX_sizecache        int32                      `json:"-" pg:"-"`
}

func (m *FileChallengeQuestions) Reset()         { *m = FileChallengeQuestions{} }
func (m *FileChallengeQuestions) String() string { return proto.CompactTextString(m) }
func (*FileChallengeQuestions) ProtoMessage()    {}
func (*FileChallengeQuestions) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{8}
}
func (m *FileChallengeQuestions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileChallengeQuestions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileChallengeQuestions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileChallengeQuestions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileChallengeQuestions.Merge(m, src)
}
func (m *FileChallengeQuestions) XXX_Size() int {
	return m.Size()
}
func (m *FileChallengeQuestions) XXX_DiscardUnknown() {
	xxx_messageInfo_FileChallengeQuestions.DiscardUnknown(m)
}

var xxx_messageInfo_FileChallengeQuestions proto.InternalMessageInfo

func (m *FileChallengeQuestions) GetFileHash() string {
	if m != nil {
		return m.FileHash
	}
	return ""
}

func (m *FileChallengeQuestions) GetShardQuestions() []*ShardChallengeQuestions {
	if m != nil {
		return m.ShardQuestions
	}
	return nil
}

func (*FileChallengeQuestions) XXX_MessageName() string {
	return "guard.FileChallengeQuestions"
}

type ShardChallengeQuestions struct {
	FileHash             string               `protobuf:"bytes,1,opt,name=file_hash,json=fileHash,proto3" json:"file_hash,omitempty" pg:"file_hash"`
	ShardHash            string               `protobuf:"bytes,2,opt,name=shard_hash,json=shardHash,proto3" json:"shard_hash,omitempty" pg:"shard_hash"`
	PreparerPid          string               `protobuf:"bytes,3,opt,name=preparer_pid,json=preparerPid,proto3" json:"preparer_pid,omitempty" pg:"preparer_pid"`
	QuestionCount        int32                `protobuf:"varint,4,opt,name=question_count,json=questionCount,proto3" json:"question_count,omitempty" pg:"question_count"`
	Questions            []*ChallengeQuestion `protobuf:"bytes,5,rep,name=questions,proto3" json:"questions,omitempty" pg:"questions"`
	PrepareTime          time.Time            `protobuf:"bytes,6,opt,name=prepare_time,json=prepareTime,proto3,stdtime" json:"prepare_time" pg:"prepare_time"`
	PreparerSignature    []byte               `protobuf:"bytes,7,opt,name=preparer_signature,json=preparerSignature,proto3" json:"preparer_signature,omitempty" pg:"preparer_signature"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-" pg:"-"`
	XXX_unrecognized     []byte               `json:"-" pg:"-"`
	XXX_sizecache        int32                `json:"-" pg:"-"`
}

func (m *ShardChallengeQuestions) Reset()         { *m = ShardChallengeQuestions{} }
func (m *ShardChallengeQuestions) String() string { return proto.CompactTextString(m) }
func (*ShardChallengeQuestions) ProtoMessage()    {}
func (*ShardChallengeQuestions) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{9}
}
func (m *ShardChallengeQuestions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardChallengeQuestions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardChallengeQuestions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardChallengeQuestions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardChallengeQuestions.Merge(m, src)
}
func (m *ShardChallengeQuestions) XXX_Size() int {
	return m.Size()
}
func (m *ShardChallengeQuestions) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardChallengeQuestions.DiscardUnknown(m)
}

var xxx_messageInfo_ShardChallengeQuestions proto.InternalMessageInfo

func (m *ShardChallengeQuestions) GetFileHash() string {
	if m != nil {
		return m.FileHash
	}
	return ""
}

func (m *ShardChallengeQuestions) GetShardHash() string {
	if m != nil {
		return m.ShardHash
	}
	return ""
}

func (m *ShardChallengeQuestions) GetPreparerPid() string {
	if m != nil {
		return m.PreparerPid
	}
	return ""
}

func (m *ShardChallengeQuestions) GetQuestionCount() int32 {
	if m != nil {
		return m.QuestionCount
	}
	return 0
}

func (m *ShardChallengeQuestions) GetQuestions() []*ChallengeQuestion {
	if m != nil {
		return m.Questions
	}
	return nil
}

func (m *ShardChallengeQuestions) GetPrepareTime() time.Time {
	if m != nil {
		return m.PrepareTime
	}
	return time.Time{}
}

func (m *ShardChallengeQuestions) GetPreparerSignature() []byte {
	if m != nil {
		return m.PreparerSignature
	}
	return nil
}

func (*ShardChallengeQuestions) XXX_MessageName() string {
	return "guard.ShardChallengeQuestions"
}

type CheckFileStoreMetaRequest struct {
	FileHash             string    `protobuf:"bytes,1,opt,name=file_hash,json=fileHash,proto3" json:"file_hash,omitempty" pg:"file_hash"`
	RenterPid            string    `protobuf:"bytes,2,opt,name=renter_pid,json=renterPid,proto3" json:"renter_pid,omitempty" pg:"renter_pid"`
	RequesterPid         string    `protobuf:"bytes,3,opt,name=requester_pid,json=requesterPid,proto3" json:"requester_pid,omitempty" pg:"requester_pid"`
	RequestTime          time.Time `protobuf:"bytes,4,opt,name=request_time,json=requestTime,proto3,stdtime" json:"request_time" pg:"request_time"`
	Signature            []byte    `protobuf:"bytes,5,opt,name=signature,proto3" json:"signature,omitempty" pg:"signature"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-" pg:"-"`
	XXX_unrecognized     []byte    `json:"-" pg:"-"`
	XXX_sizecache        int32     `json:"-" pg:"-"`
}

func (m *CheckFileStoreMetaRequest) Reset()         { *m = CheckFileStoreMetaRequest{} }
func (m *CheckFileStoreMetaRequest) String() string { return proto.CompactTextString(m) }
func (*CheckFileStoreMetaRequest) ProtoMessage()    {}
func (*CheckFileStoreMetaRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{10}
}
func (m *CheckFileStoreMetaRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckFileStoreMetaRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckFileStoreMetaRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckFileStoreMetaRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckFileStoreMetaRequest.Merge(m, src)
}
func (m *CheckFileStoreMetaRequest) XXX_Size() int {
	return m.Size()
}
func (m *CheckFileStoreMetaRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckFileStoreMetaRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CheckFileStoreMetaRequest proto.InternalMessageInfo

func (m *CheckFileStoreMetaRequest) GetFileHash() string {
	if m != nil {
		return m.FileHash
	}
	return ""
}

func (m *CheckFileStoreMetaRequest) GetRenterPid() string {
	if m != nil {
		return m.RenterPid
	}
	return ""
}

func (m *CheckFileStoreMetaRequest) GetRequesterPid() string {
	if m != nil {
		return m.RequesterPid
	}
	return ""
}

func (m *CheckFileStoreMetaRequest) GetRequestTime() time.Time {
	if m != nil {
		return m.RequestTime
	}
	return time.Time{}
}

func (m *CheckFileStoreMetaRequest) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (*CheckFileStoreMetaRequest) XXX_MessageName() string {
	return "guard.CheckFileStoreMetaRequest"
}

type ListRenterFileInfoRequest struct {
	RenterPid            string     `protobuf:"bytes,1,opt,name=renter_pid,json=renterPid,proto3" json:"renter_pid,omitempty" pg:"renter_pid"`
	RequesterPid         string     `protobuf:"bytes,2,opt,name=requester_pid,json=requesterPid,proto3" json:"requester_pid,omitempty" pg:"requester_pid"`
	RequestPageSize      int32      `protobuf:"varint,3,opt,name=request_page_size,json=requestPageSize,proto3" json:"request_page_size,omitempty" pg:"request_page_size"`
	RequestPageIndex     int32      `protobuf:"varint,4,opt,name=request_page_index,json=requestPageIndex,proto3" json:"request_page_index,omitempty" pg:"request_page_index"`
	RequestTime          *time.Time `protobuf:"bytes,5,opt,name=request_time,json=requestTime,proto3,stdtime" json:"request_time,omitempty" pg:"request_time"`
	LastModifyTime       *time.Time `protobuf:"bytes,6,opt,name=last_modify_time,json=lastModifyTime,proto3,stdtime" json:"last_modify_time,omitempty" pg:"last_modify_time"`
	Signature            []byte     `protobuf:"bytes,7,opt,name=signature,proto3" json:"signature,omitempty" pg:"signature"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-" pg:"-"`
	XXX_unrecognized     []byte     `json:"-" pg:"-"`
	XXX_sizecache        int32      `json:"-" pg:"-"`
}

func (m *ListRenterFileInfoRequest) Reset()         { *m = ListRenterFileInfoRequest{} }
func (m *ListRenterFileInfoRequest) String() string { return proto.CompactTextString(m) }
func (*ListRenterFileInfoRequest) ProtoMessage()    {}
func (*ListRenterFileInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{11}
}
func (m *ListRenterFileInfoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListRenterFileInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListRenterFileInfoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListRenterFileInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListRenterFileInfoRequest.Merge(m, src)
}
func (m *ListRenterFileInfoRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListRenterFileInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListRenterFileInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListRenterFileInfoRequest proto.InternalMessageInfo

func (m *ListRenterFileInfoRequest) GetRenterPid() string {
	if m != nil {
		return m.RenterPid
	}
	return ""
}

func (m *ListRenterFileInfoRequest) GetRequesterPid() string {
	if m != nil {
		return m.RequesterPid
	}
	return ""
}

func (m *ListRenterFileInfoRequest) GetRequestPageSize() int32 {
	if m != nil {
		return m.RequestPageSize
	}
	return 0
}

func (m *ListRenterFileInfoRequest) GetRequestPageIndex() int32 {
	if m != nil {
		return m.RequestPageIndex
	}
	return 0
}

func (m *ListRenterFileInfoRequest) GetRequestTime() *time.Time {
	if m != nil {
		return m.RequestTime
	}
	return nil
}

func (m *ListRenterFileInfoRequest) GetLastModifyTime() *time.Time {
	if m != nil {
		return m.LastModifyTime
	}
	return nil
}

func (m *ListRenterFileInfoRequest) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (*ListRenterFileInfoRequest) XXX_MessageName() string {
	return "guard.ListRenterFileInfoRequest"
}

type ListHostContractsRequest struct {
	HostPid              string                               `protobuf:"bytes,1,opt,name=host_pid,json=hostPid,proto3" json:"host_pid,omitempty" pg:"host_pid"`
	RequesterPid         string                               `protobuf:"bytes,2,opt,name=requester_pid,json=requesterPid,proto3" json:"requester_pid,omitempty" pg:"requester_pid"`
	RequestPageSize      int32                                `protobuf:"varint,3,opt,name=request_page_size,json=requestPageSize,proto3" json:"request_page_size,omitempty" pg:"request_page_size"`
	RequestPageIndex     int32                                `protobuf:"varint,4,opt,name=request_page_index,json=requestPageIndex,proto3" json:"request_page_index,omitempty" pg:"request_page_index"`
	LastModifyTimeSince  *time.Time                           `protobuf:"bytes,5,opt,name=last_modify_time_since,json=lastModifyTimeSince,proto3,stdtime" json:"last_modify_time_since,omitempty" pg:"last_modify_time_since"`
	LastModifyTimeTo     *time.Time                           `protobuf:"bytes,6,opt,name=last_modify_time_to,json=lastModifyTimeTo,proto3,stdtime" json:"last_modify_time_to,omitempty" pg:"last_modify_time_to"`
	State                ListHostContractsRequest_SelectState `protobuf:"varint,7,opt,name=state,proto3,enum=guard.ListHostContractsRequest_SelectState" json:"state,omitempty" pg:"state"`
	RequestTime          *time.Time                           `protobuf:"bytes,8,opt,name=request_time,json=requestTime,proto3,stdtime" json:"request_time,omitempty" pg:"request_time"`
	Signature            []byte                               `protobuf:"bytes,9,opt,name=signature,proto3" json:"signature,omitempty" pg:"signature"`
	XXX_NoUnkeyedLiteral struct{}                             `json:"-" pg:"-"`
	XXX_unrecognized     []byte                               `json:"-" pg:"-"`
	XXX_sizecache        int32                                `json:"-" pg:"-"`
}

func (m *ListHostContractsRequest) Reset()         { *m = ListHostContractsRequest{} }
func (m *ListHostContractsRequest) String() string { return proto.CompactTextString(m) }
func (*ListHostContractsRequest) ProtoMessage()    {}
func (*ListHostContractsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{12}
}
func (m *ListHostContractsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListHostContractsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListHostContractsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListHostContractsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListHostContractsRequest.Merge(m, src)
}
func (m *ListHostContractsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListHostContractsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListHostContractsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListHostContractsRequest proto.InternalMessageInfo

func (m *ListHostContractsRequest) GetHostPid() string {
	if m != nil {
		return m.HostPid
	}
	return ""
}

func (m *ListHostContractsRequest) GetRequesterPid() string {
	if m != nil {
		return m.RequesterPid
	}
	return ""
}

func (m *ListHostContractsRequest) GetRequestPageSize() int32 {
	if m != nil {
		return m.RequestPageSize
	}
	return 0
}

func (m *ListHostContractsRequest) GetRequestPageIndex() int32 {
	if m != nil {
		return m.RequestPageIndex
	}
	return 0
}

func (m *ListHostContractsRequest) GetLastModifyTimeSince() *time.Time {
	if m != nil {
		return m.LastModifyTimeSince
	}
	return nil
}

func (m *ListHostContractsRequest) GetLastModifyTimeTo() *time.Time {
	if m != nil {
		return m.LastModifyTimeTo
	}
	return nil
}

func (m *ListHostContractsRequest) GetState() ListHostContractsRequest_SelectState {
	if m != nil {
		return m.State
	}
	return ListHostContractsRequest_ALL
}

func (m *ListHostContractsRequest) GetRequestTime() *time.Time {
	if m != nil {
		return m.RequestTime
	}
	return nil
}

func (m *ListHostContractsRequest) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (*ListHostContractsRequest) XXX_MessageName() string {
	return "guard.ListHostContractsRequest"
}

type ContractsList struct {
	Request              *ListHostContractsRequest `protobuf:"bytes,1,opt,name=request,proto3" json:"request,omitempty" pg:"request"`
	GenerateTime         time.Time                 `protobuf:"bytes,2,opt,name=generate_time,json=generateTime,proto3,stdtime" json:"generate_time" pg:"generate_time"`
	Contracts            []*Contract               `protobuf:"bytes,3,rep,name=contracts,proto3" json:"contracts,omitempty" pg:"contracts"`
	Count                int32                     `protobuf:"varint,4,opt,name=count,proto3" json:"count,omitempty" pg:"count"`
	Signature            []byte                    `protobuf:"bytes,5,opt,name=signature,proto3" json:"signature,omitempty" pg:"signature"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-" pg:"-"`
	XXX_unrecognized     []byte                    `json:"-" pg:"-"`
	XXX_sizecache        int32                     `json:"-" pg:"-"`
}

func (m *ContractsList) Reset()         { *m = ContractsList{} }
func (m *ContractsList) String() string { return proto.CompactTextString(m) }
func (*ContractsList) ProtoMessage()    {}
func (*ContractsList) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{13}
}
func (m *ContractsList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContractsList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContractsList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContractsList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContractsList.Merge(m, src)
}
func (m *ContractsList) XXX_Size() int {
	return m.Size()
}
func (m *ContractsList) XXX_DiscardUnknown() {
	xxx_messageInfo_ContractsList.DiscardUnknown(m)
}

var xxx_messageInfo_ContractsList proto.InternalMessageInfo

func (m *ContractsList) GetRequest() *ListHostContractsRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *ContractsList) GetGenerateTime() time.Time {
	if m != nil {
		return m.GenerateTime
	}
	return time.Time{}
}

func (m *ContractsList) GetContracts() []*Contract {
	if m != nil {
		return m.Contracts
	}
	return nil
}

func (m *ContractsList) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *ContractsList) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (*ContractsList) XXX_MessageName() string {
	return "guard.ContractsList"
}

type ReadyForChallengeRequest struct {
	RenterPid            string    `protobuf:"bytes,1,opt,name=renter_pid,json=renterPid,proto3" json:"renter_pid,omitempty" pg:"renter_pid"`
	FileHash             string    `protobuf:"bytes,2,opt,name=file_hash,json=fileHash,proto3" json:"file_hash,omitempty" pg:"file_hash"`
	ShardHash            string    `protobuf:"bytes,3,opt,name=shard_hash,json=shardHash,proto3" json:"shard_hash,omitempty" pg:"shard_hash"`
	ContractId           string    `protobuf:"bytes,4,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty" pg:"contract_id"`
	HostPid              string    `protobuf:"bytes,5,opt,name=host_pid,json=hostPid,proto3" json:"host_pid,omitempty" pg:"host_pid"`
	PrepareTime          time.Time `protobuf:"bytes,6,opt,name=prepare_time,json=prepareTime,proto3,stdtime" json:"prepare_time" pg:"prepare_time"`
	Signature            []byte    `protobuf:"bytes,7,opt,name=signature,proto3" json:"signature,omitempty" pg:"signature"`
	IsRepair             bool      `protobuf:"varint,8,opt,name=is_repair,json=isRepair,proto3" json:"is_repair,omitempty" pg:"is_repair"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-" pg:"-"`
	XXX_unrecognized     []byte    `json:"-" pg:"-"`
	XXX_sizecache        int32     `json:"-" pg:"-"`
}

func (m *ReadyForChallengeRequest) Reset()         { *m = ReadyForChallengeRequest{} }
func (m *ReadyForChallengeRequest) String() string { return proto.CompactTextString(m) }
func (*ReadyForChallengeRequest) ProtoMessage()    {}
func (*ReadyForChallengeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{14}
}
func (m *ReadyForChallengeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadyForChallengeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReadyForChallengeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReadyForChallengeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadyForChallengeRequest.Merge(m, src)
}
func (m *ReadyForChallengeRequest) XXX_Size() int {
	return m.Size()
}
func (m *ReadyForChallengeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadyForChallengeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ReadyForChallengeRequest proto.InternalMessageInfo

func (m *ReadyForChallengeRequest) GetRenterPid() string {
	if m != nil {
		return m.RenterPid
	}
	return ""
}

func (m *ReadyForChallengeRequest) GetFileHash() string {
	if m != nil {
		return m.FileHash
	}
	return ""
}

func (m *ReadyForChallengeRequest) GetShardHash() string {
	if m != nil {
		return m.ShardHash
	}
	return ""
}

func (m *ReadyForChallengeRequest) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *ReadyForChallengeRequest) GetHostPid() string {
	if m != nil {
		return m.HostPid
	}
	return ""
}

func (m *ReadyForChallengeRequest) GetPrepareTime() time.Time {
	if m != nil {
		return m.PrepareTime
	}
	return time.Time{}
}

func (m *ReadyForChallengeRequest) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *ReadyForChallengeRequest) GetIsRepair() bool {
	if m != nil {
		return m.IsRepair
	}
	return false
}

func (*ReadyForChallengeRequest) XXX_MessageName() string {
	return "guard.ReadyForChallengeRequest"
}

type RequestChallengeQuestion struct {
	Question             *ChallengeQuestion `protobuf:"bytes,1,opt,name=question,proto3" json:"question,omitempty" pg:"question"`
	PrepareTime          time.Time          `protobuf:"bytes,2,opt,name=prepare_time,json=prepareTime,proto3,stdtime" json:"prepare_time" pg:"prepare_time"`
	Signature            []byte             `protobuf:"bytes,3,opt,name=signature,proto3" json:"signature,omitempty" pg:"signature"`
	IsRepair             bool               `protobuf:"varint,4,opt,name=is_repair,json=isRepair,proto3" json:"is_repair,omitempty" pg:"is_repair"`
	FileHash             string             `protobuf:"bytes,5,opt,name=file_hash,json=fileHash,proto3" json:"file_hash,omitempty" pg:"file_hash"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-" pg:"-"`
	XXX_unrecognized     []byte             `json:"-" pg:"-"`
	XXX_sizecache        int32              `json:"-" pg:"-"`
}

func (m *RequestChallengeQuestion) Reset()         { *m = RequestChallengeQuestion{} }
func (m *RequestChallengeQuestion) String() string { return proto.CompactTextString(m) }
func (*RequestChallengeQuestion) ProtoMessage()    {}
func (*RequestChallengeQuestion) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{15}
}
func (m *RequestChallengeQuestion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestChallengeQuestion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestChallengeQuestion.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestChallengeQuestion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestChallengeQuestion.Merge(m, src)
}
func (m *RequestChallengeQuestion) XXX_Size() int {
	return m.Size()
}
func (m *RequestChallengeQuestion) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestChallengeQuestion.DiscardUnknown(m)
}

var xxx_messageInfo_RequestChallengeQuestion proto.InternalMessageInfo

func (m *RequestChallengeQuestion) GetQuestion() *ChallengeQuestion {
	if m != nil {
		return m.Question
	}
	return nil
}

func (m *RequestChallengeQuestion) GetPrepareTime() time.Time {
	if m != nil {
		return m.PrepareTime
	}
	return time.Time{}
}

func (m *RequestChallengeQuestion) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *RequestChallengeQuestion) GetIsRepair() bool {
	if m != nil {
		return m.IsRepair
	}
	return false
}

func (m *RequestChallengeQuestion) GetFileHash() string {
	if m != nil {
		return m.FileHash
	}
	return ""
}

func (*RequestChallengeQuestion) XXX_MessageName() string {
	return "guard.RequestChallengeQuestion"
}

type ResponseChallengeQuestion struct {
	Answer               *ChallengeQuestion `protobuf:"bytes,1,opt,name=answer,proto3" json:"answer,omitempty" pg:"answer"`
	HostPid              string             `protobuf:"bytes,2,opt,name=host_pid,json=hostPid,proto3" json:"host_pid,omitempty" pg:"host_pid"`
	ResolveTime          time.Time          `protobuf:"bytes,3,opt,name=resolve_time,json=resolveTime,proto3,stdtime" json:"resolve_time" pg:"resolve_time"`
	Signature            []byte             `protobuf:"bytes,4,opt,name=signature,proto3" json:"signature,omitempty" pg:"signature"`
	IsRepair             bool               `protobuf:"varint,5,opt,name=is_repair,json=isRepair,proto3" json:"is_repair,omitempty" pg:"is_repair"`
	FileHash             string             `protobuf:"bytes,6,opt,name=file_hash,json=fileHash,proto3" json:"file_hash,omitempty" pg:"file_hash"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-" pg:"-"`
	XXX_unrecognized     []byte             `json:"-" pg:"-"`
	XXX_sizecache        int32              `json:"-" pg:"-"`
}

func (m *ResponseChallengeQuestion) Reset()         { *m = ResponseChallengeQuestion{} }
func (m *ResponseChallengeQuestion) String() string { return proto.CompactTextString(m) }
func (*ResponseChallengeQuestion) ProtoMessage()    {}
func (*ResponseChallengeQuestion) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{16}
}
func (m *ResponseChallengeQuestion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseChallengeQuestion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseChallengeQuestion.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseChallengeQuestion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseChallengeQuestion.Merge(m, src)
}
func (m *ResponseChallengeQuestion) XXX_Size() int {
	return m.Size()
}
func (m *ResponseChallengeQuestion) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseChallengeQuestion.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseChallengeQuestion proto.InternalMessageInfo

func (m *ResponseChallengeQuestion) GetAnswer() *ChallengeQuestion {
	if m != nil {
		return m.Answer
	}
	return nil
}

func (m *ResponseChallengeQuestion) GetHostPid() string {
	if m != nil {
		return m.HostPid
	}
	return ""
}

func (m *ResponseChallengeQuestion) GetResolveTime() time.Time {
	if m != nil {
		return m.ResolveTime
	}
	return time.Time{}
}

func (m *ResponseChallengeQuestion) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *ResponseChallengeQuestion) GetIsRepair() bool {
	if m != nil {
		return m.IsRepair
	}
	return false
}

func (m *ResponseChallengeQuestion) GetFileHash() string {
	if m != nil {
		return m.FileHash
	}
	return ""
}

func (*ResponseChallengeQuestion) XXX_MessageName() string {
	return "guard.ResponseChallengeQuestion"
}

type ForceRepairRequest struct {
	RenterPid            string   `protobuf:"bytes,1,opt,name=renter_pid,json=renterPid,proto3" json:"renter_pid,omitempty" pg:"renter_pid"`
	FileHash             string   `protobuf:"bytes,2,opt,name=file_hash,json=fileHash,proto3" json:"file_hash,omitempty" pg:"file_hash"`
	AuthPid              string   `protobuf:"bytes,3,opt,name=auth_pid,json=authPid,proto3" json:"auth_pid,omitempty" pg:"auth_pid"`
	Signature            []byte   `protobuf:"bytes,4,opt,name=signature,proto3" json:"signature,omitempty" pg:"signature"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" pg:"-"`
	XXX_unrecognized     []byte   `json:"-" pg:"-"`
	XXX_sizecache        int32    `json:"-" pg:"-"`
}

func (m *ForceRepairRequest) Reset()         { *m = ForceRepairRequest{} }
func (m *ForceRepairRequest) String() string { return proto.CompactTextString(m) }
func (*ForceRepairRequest) ProtoMessage()    {}
func (*ForceRepairRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{17}
}
func (m *ForceRepairRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ForceRepairRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ForceRepairRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ForceRepairRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ForceRepairRequest.Merge(m, src)
}
func (m *ForceRepairRequest) XXX_Size() int {
	return m.Size()
}
func (m *ForceRepairRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ForceRepairRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ForceRepairRequest proto.InternalMessageInfo

func (m *ForceRepairRequest) GetRenterPid() string {
	if m != nil {
		return m.RenterPid
	}
	return ""
}

func (m *ForceRepairRequest) GetFileHash() string {
	if m != nil {
		return m.FileHash
	}
	return ""
}

func (m *ForceRepairRequest) GetAuthPid() string {
	if m != nil {
		return m.AuthPid
	}
	return ""
}

func (m *ForceRepairRequest) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (*ForceRepairRequest) XXX_MessageName() string {
	return "guard.ForceRepairRequest"
}

type Result struct {
	Code                 ResponseCode `protobuf:"varint,1,opt,name=code,proto3,enum=guard.ResponseCode" json:"code,omitempty" pg:"code"`
	Message              string       `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty" pg:"message"`
	ResponseTime         time.Time    `protobuf:"bytes,3,opt,name=response_time,json=responseTime,proto3,stdtime" json:"response_time" pg:"response_time"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-" pg:"-"`
	XXX_unrecognized     []byte       `json:"-" pg:"-"`
	XXX_sizecache        int32        `json:"-" pg:"-"`
}

func (m *Result) Reset()         { *m = Result{} }
func (m *Result) String() string { return proto.CompactTextString(m) }
func (*Result) ProtoMessage()    {}
func (*Result) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{18}
}
func (m *Result) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Result) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Result.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Result) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Result.Merge(m, src)
}
func (m *Result) XXX_Size() int {
	return m.Size()
}
func (m *Result) XXX_DiscardUnknown() {
	xxx_messageInfo_Result.DiscardUnknown(m)
}

var xxx_messageInfo_Result proto.InternalMessageInfo

func (m *Result) GetCode() ResponseCode {
	if m != nil {
		return m.Code
	}
	return ResponseCode_SUCCESS
}

func (m *Result) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *Result) GetResponseTime() time.Time {
	if m != nil {
		return m.ResponseTime
	}
	return time.Time{}
}

func (*Result) XXX_MessageName() string {
	return "guard.Result"
}

type RepairContract struct {
	FileHash             string    `protobuf:"bytes,1,opt,name=file_hash,json=fileHash,proto3" json:"file_hash,omitempty" pg:"file_hash"`
	LostShardHash        []string  `protobuf:"bytes,2,rep,name=lost_shard_hash,json=lostShardHash,proto3" json:"lost_shard_hash,omitempty" pg:"lost_shard_hash"`
	FileSize             int64     `protobuf:"varint,3,opt,name=file_size,json=fileSize,proto3" json:"file_size,omitempty" pg:"file_size"`
	DownloadRewardAmount int64     `protobuf:"varint,4,opt,name=download_reward_amount,json=downloadRewardAmount,proto3" json:"download_reward_amount,omitempty" pg:"download_reward_amount"`
	RepairRewardAmount   int64     `protobuf:"varint,5,opt,name=repair_reward_amount,json=repairRewardAmount,proto3" json:"repair_reward_amount,omitempty" pg:"repair_reward_amount"`
	RepairPid            string    `protobuf:"bytes,6,opt,name=repair_pid,json=repairPid,proto3" json:"repair_pid,omitempty" pg:"repair_pid"`
	RepairSignTime       time.Time `protobuf:"bytes,7,opt,name=repair_sign_time,json=repairSignTime,proto3,stdtime" json:"repair_sign_time" pg:"repair_sign_time"`
	RepairSignature      []byte    `protobuf:"bytes,8,opt,name=repair_signature,json=repairSignature,proto3" json:"repair_signature,omitempty" pg:"repair_signature"`
	DownloadContractId   string    `protobuf:"bytes,9,opt,name=download_contract_id,json=downloadContractId,proto3" json:"download_contract_id,omitempty" pg:"download_contract_id"`
	RepairContractId     string    `protobuf:"bytes,10,opt,name=repair_contract_id,json=repairContractId,proto3" json:"repair_contract_id,omitempty" pg:"repair_contract_id"`
	GuardSignTime        time.Time `protobuf:"bytes,11,opt,name=guard_sign_time,json=guardSignTime,proto3,stdtime" json:"guard_sign_time" pg:"guard_sign_time"`
	GuardSignature       []byte    `protobuf:"bytes,12,opt,name=guard_signature,json=guardSignature,proto3" json:"guard_signature,omitempty" pg:"guard_signature"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-" pg:"-"`
	XXX_unrecognized     []byte    `json:"-" pg:"-"`
	XXX_sizecache        int32     `json:"-" pg:"-"`
}

func (m *RepairContract) Reset()         { *m = RepairContract{} }
func (m *RepairContract) String() string { return proto.CompactTextString(m) }
func (*RepairContract) ProtoMessage()    {}
func (*RepairContract) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{19}
}
func (m *RepairContract) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RepairContract) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RepairContract.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RepairContract) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RepairContract.Merge(m, src)
}
func (m *RepairContract) XXX_Size() int {
	return m.Size()
}
func (m *RepairContract) XXX_DiscardUnknown() {
	xxx_messageInfo_RepairContract.DiscardUnknown(m)
}

var xxx_messageInfo_RepairContract proto.InternalMessageInfo

func (m *RepairContract) GetFileHash() string {
	if m != nil {
		return m.FileHash
	}
	return ""
}

func (m *RepairContract) GetLostShardHash() []string {
	if m != nil {
		return m.LostShardHash
	}
	return nil
}

func (m *RepairContract) GetFileSize() int64 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

func (m *RepairContract) GetDownloadRewardAmount() int64 {
	if m != nil {
		return m.DownloadRewardAmount
	}
	return 0
}

func (m *RepairContract) GetRepairRewardAmount() int64 {
	if m != nil {
		return m.RepairRewardAmount
	}
	return 0
}

func (m *RepairContract) GetRepairPid() string {
	if m != nil {
		return m.RepairPid
	}
	return ""
}

func (m *RepairContract) GetRepairSignTime() time.Time {
	if m != nil {
		return m.RepairSignTime
	}
	return time.Time{}
}

func (m *RepairContract) GetRepairSignature() []byte {
	if m != nil {
		return m.RepairSignature
	}
	return nil
}

func (m *RepairContract) GetDownloadContractId() string {
	if m != nil {
		return m.DownloadContractId
	}
	return ""
}

func (m *RepairContract) GetRepairContractId() string {
	if m != nil {
		return m.RepairContractId
	}
	return ""
}

func (m *RepairContract) GetGuardSignTime() time.Time {
	if m != nil {
		return m.GuardSignTime
	}
	return time.Time{}
}

func (m *RepairContract) GetGuardSignature() []byte {
	if m != nil {
		return m.GuardSignature
	}
	return nil
}

func (*RepairContract) XXX_MessageName() string {
	return "guard.RepairContract"
}

type RepairContractResponse struct {
	Contract             *RepairContract                               `protobuf:"bytes,1,opt,name=contract,proto3" json:"contract,omitempty" pg:"contract"`
	Status               RepairContractResponse_ContractResponseStatus `protobuf:"varint,2,opt,name=status,proto3,enum=guard.RepairContractResponse_ContractResponseStatus" json:"status,omitempty" pg:"status"`
	XXX_NoUnkeyedLiteral struct{}                                      `json:"-" pg:"-"`
	XXX_unrecognized     []byte                                        `json:"-" pg:"-"`
	XXX_sizecache        int32                                         `json:"-" pg:"-"`
}

func (m *RepairContractResponse) Reset()         { *m = RepairContractResponse{} }
func (m *RepairContractResponse) String() string { return proto.CompactTextString(m) }
func (*RepairContractResponse) ProtoMessage()    {}
func (*RepairContractResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{20}
}
func (m *RepairContractResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RepairContractResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RepairContractResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RepairContractResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RepairContractResponse.Merge(m, src)
}
func (m *RepairContractResponse) XXX_Size() int {
	return m.Size()
}
func (m *RepairContractResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RepairContractResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RepairContractResponse proto.InternalMessageInfo

func (m *RepairContractResponse) GetContract() *RepairContract {
	if m != nil {
		return m.Contract
	}
	return nil
}

func (m *RepairContractResponse) GetStatus() RepairContractResponse_ContractResponseStatus {
	if m != nil {
		return m.Status
	}
	return RepairContractResponse_BOTH_SIGNED
}

func (*RepairContractResponse) XXX_MessageName() string {
	return "guard.RepairContractResponse"
}

type RequestRepairContracts struct {
	FileHash             string    `protobuf:"bytes,1,opt,name=file_hash,json=fileHash,proto3" json:"file_hash,omitempty" pg:"file_hash"`
	RepairNode           string    `protobuf:"bytes,2,opt,name=repair_node,json=repairNode,proto3" json:"repair_node,omitempty" pg:"repair_node"`
	RepairSignTime       time.Time `protobuf:"bytes,3,opt,name=repair_sign_time,json=repairSignTime,proto3,stdtime" json:"repair_sign_time" pg:"repair_sign_time"`
	RepairSignature      []byte    `protobuf:"bytes,4,opt,name=repair_signature,json=repairSignature,proto3" json:"repair_signature,omitempty" pg:"repair_signature"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-" pg:"-"`
	XXX_unrecognized     []byte    `json:"-" pg:"-"`
	XXX_sizecache        int32     `json:"-" pg:"-"`
}

func (m *RequestRepairContracts) Reset()         { *m = RequestRepairContracts{} }
func (m *RequestRepairContracts) String() string { return proto.CompactTextString(m) }
func (*RequestRepairContracts) ProtoMessage()    {}
func (*RequestRepairContracts) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{21}
}
func (m *RequestRepairContracts) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestRepairContracts) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestRepairContracts.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestRepairContracts) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestRepairContracts.Merge(m, src)
}
func (m *RequestRepairContracts) XXX_Size() int {
	return m.Size()
}
func (m *RequestRepairContracts) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestRepairContracts.DiscardUnknown(m)
}

var xxx_messageInfo_RequestRepairContracts proto.InternalMessageInfo

func (m *RequestRepairContracts) GetFileHash() string {
	if m != nil {
		return m.FileHash
	}
	return ""
}

func (m *RequestRepairContracts) GetRepairNode() string {
	if m != nil {
		return m.RepairNode
	}
	return ""
}

func (m *RequestRepairContracts) GetRepairSignTime() time.Time {
	if m != nil {
		return m.RepairSignTime
	}
	return time.Time{}
}

func (m *RequestRepairContracts) GetRepairSignature() []byte {
	if m != nil {
		return m.RepairSignature
	}
	return nil
}

func (*RequestRepairContracts) XXX_MessageName() string {
	return "guard.RequestRepairContracts"
}

type ResponseRepairContracts struct {
	FileHash             string                             `protobuf:"bytes,1,opt,name=file_hash,json=fileHash,proto3" json:"file_hash,omitempty" pg:"file_hash"`
	RepairNode           string                             `protobuf:"bytes,2,opt,name=repair_node,json=repairNode,proto3" json:"repair_node,omitempty" pg:"repair_node"`
	State                ResponseRepairContracts_RepairStat `protobuf:"varint,3,opt,name=state,proto3,enum=guard.ResponseRepairContracts_RepairStat" json:"state,omitempty" pg:"state"`
	Status               *FileStoreStatus                   `protobuf:"bytes,4,opt,name=status,proto3" json:"status,omitempty" pg:"status"`
	GuardPid             string                             `protobuf:"bytes,5,opt,name=guard_pid,json=guardPid,proto3" json:"guard_pid,omitempty" pg:"guard_pid"`
	SignTime             time.Time                          `protobuf:"bytes,6,opt,name=sign_time,json=signTime,proto3,stdtime" json:"sign_time" pg:"sign_time"`
	GuardSignature       []byte                             `protobuf:"bytes,7,opt,name=guard_signature,json=guardSignature,proto3" json:"guard_signature,omitempty" pg:"guard_signature"`
	XXX_NoUnkeyedLiteral struct{}                           `json:"-" pg:"-"`
	XXX_unrecognized     []byte                             `json:"-" pg:"-"`
	XXX_sizecache        int32                              `json:"-" pg:"-"`
}

func (m *ResponseRepairContracts) Reset()         { *m = ResponseRepairContracts{} }
func (m *ResponseRepairContracts) String() string { return proto.CompactTextString(m) }
func (*ResponseRepairContracts) ProtoMessage()    {}
func (*ResponseRepairContracts) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad5b6eccdc9ebee8, []int{22}
}
func (m *ResponseRepairContracts) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseRepairContracts) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseRepairContracts.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseRepairContracts) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseRepairContracts.Merge(m, src)
}
func (m *ResponseRepairContracts) XXX_Size() int {
	return m.Size()
}
func (m *ResponseRepairContracts) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseRepairContracts.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseRepairContracts proto.InternalMessageInfo

func (m *ResponseRepairContracts) GetFileHash() string {
	if m != nil {
		return m.FileHash
	}
	return ""
}

func (m *ResponseRepairContracts) GetRepairNode() string {
	if m != nil {
		return m.RepairNode
	}
	return ""
}

func (m *ResponseRepairContracts) GetState() ResponseRepairContracts_RepairStat {
	if m != nil {
		return m.State
	}
	return ResponseRepairContracts_CONTRACT_READY
}

func (m *ResponseRepairContracts) GetStatus() *FileStoreStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *ResponseRepairContracts) GetGuardPid() string {
	if m != nil {
		return m.GuardPid
	}
	return ""
}

func (m *ResponseRepairContracts) GetSignTime() time.Time {
	if m != nil {
		return m.SignTime
	}
	return time.Time{}
}

func (m *ResponseRepairContracts) GetGuardSignature() []byte {
	if m != nil {
		return m.GuardSignature
	}
	return nil
}

func (*ResponseRepairContracts) XXX_MessageName() string {
	return "guard.ResponseRepairContracts"
}
func init() {
	proto.RegisterEnum("guard.ResponseCode", ResponseCode_name, ResponseCode_value)
	golang_proto.RegisterEnum("guard.ResponseCode", ResponseCode_name, ResponseCode_value)
	proto.RegisterEnum("guard.ContractMeta_Schedule", ContractMeta_Schedule_name, ContractMeta_Schedule_value)
	golang_proto.RegisterEnum("guard.ContractMeta_Schedule", ContractMeta_Schedule_name, ContractMeta_Schedule_value)
	proto.RegisterEnum("guard.Contract_ContractState", Contract_ContractState_name, Contract_ContractState_value)
	golang_proto.RegisterEnum("guard.Contract_ContractState", Contract_ContractState_name, Contract_ContractState_value)
	proto.RegisterEnum("guard.FileStoreStatus_MetaState", FileStoreStatus_MetaState_name, FileStoreStatus_MetaState_value)
	golang_proto.RegisterEnum("guard.FileStoreStatus_MetaState", FileStoreStatus_MetaState_name, FileStoreStatus_MetaState_value)
	proto.RegisterEnum("guard.FileStoreStatus_RentalState", FileStoreStatus_RentalState_name, FileStoreStatus_RentalState_value)
	golang_proto.RegisterEnum("guard.FileStoreStatus_RentalState", FileStoreStatus_RentalState_name, FileStoreStatus_RentalState_value)
	proto.RegisterEnum("guard.ListHostContractsRequest_SelectState", ListHostContractsRequest_SelectState_name, ListHostContractsRequest_SelectState_value)
	golang_proto.RegisterEnum("guard.ListHostContractsRequest_SelectState", ListHostContractsRequest_SelectState_name, ListHostContractsRequest_SelectState_value)
	proto.RegisterEnum("guard.RepairContractResponse_ContractResponseStatus", RepairContractResponse_ContractResponseStatus_name, RepairContractResponse_ContractResponseStatus_value)
	golang_proto.RegisterEnum("guard.RepairContractResponse_ContractResponseStatus", RepairContractResponse_ContractResponseStatus_name, RepairContractResponse_ContractResponseStatus_value)
	proto.RegisterEnum("guard.ResponseRepairContracts_RepairStat", ResponseRepairContracts_RepairStat_name, ResponseRepairContracts_RepairStat_value)
	golang_proto.RegisterEnum("guard.ResponseRepairContracts_RepairStat", ResponseRepairContracts_RepairStat_name, ResponseRepairContracts_RepairStat_value)
	proto.RegisterType((*Log)(nil), "guard.Log")
	golang_proto.RegisterType((*Log)(nil), "guard.Log")
	proto.RegisterType((*ContractMeta)(nil), "guard.ContractMeta")
	golang_proto.RegisterType((*ContractMeta)(nil), "guard.ContractMeta")
	proto.RegisterType((*Contract)(nil), "guard.Contract")
	golang_proto.RegisterType((*Contract)(nil), "guard.Contract")
	proto.RegisterType((*FileStoreListResponse)(nil), "guard.FileStoreListResponse")
	golang_proto.RegisterType((*FileStoreListResponse)(nil), "guard.FileStoreListResponse")
	proto.RegisterType((*FileStoreMeta)(nil), "guard.FileStoreMeta")
	golang_proto.RegisterType((*FileStoreMeta)(nil), "guard.FileStoreMeta")
	proto.RegisterType((*FileStoreStatus)(nil), "guard.FileStoreStatus")
	golang_proto.RegisterType((*FileStoreStatus)(nil), "guard.FileStoreStatus")
	proto.RegisterType((*ChallengeQuestion)(nil), "guard.ChallengeQuestion")
	golang_proto.RegisterType((*ChallengeQuestion)(nil), "guard.ChallengeQuestion")
	proto.RegisterType((*ProofOfReplicateChallenge)(nil), "guard.ProofOfReplicateChallenge")
	golang_proto.RegisterType((*ProofOfReplicateChallenge)(nil), "guard.ProofOfReplicateChallenge")
	proto.RegisterType((*FileChallengeQuestions)(nil), "guard.FileChallengeQuestions")
	golang_proto.RegisterType((*FileChallengeQuestions)(nil), "guard.FileChallengeQuestions")
	proto.RegisterType((*ShardChallengeQuestions)(nil), "guard.ShardChallengeQuestions")
	golang_proto.RegisterType((*ShardChallengeQuestions)(nil), "guard.ShardChallengeQuestions")
	proto.RegisterType((*CheckFileStoreMetaRequest)(nil), "guard.CheckFileStoreMetaRequest")
	golang_proto.RegisterType((*CheckFileStoreMetaRequest)(nil), "guard.CheckFileStoreMetaRequest")
	proto.RegisterType((*ListRenterFileInfoRequest)(nil), "guard.ListRenterFileInfoRequest")
	golang_proto.RegisterType((*ListRenterFileInfoRequest)(nil), "guard.ListRenterFileInfoRequest")
	proto.RegisterType((*ListHostContractsRequest)(nil), "guard.ListHostContractsRequest")
	golang_proto.RegisterType((*ListHostContractsRequest)(nil), "guard.ListHostContractsRequest")
	proto.RegisterType((*ContractsList)(nil), "guard.ContractsList")
	golang_proto.RegisterType((*ContractsList)(nil), "guard.ContractsList")
	proto.RegisterType((*ReadyForChallengeRequest)(nil), "guard.ReadyForChallengeRequest")
	golang_proto.RegisterType((*ReadyForChallengeRequest)(nil), "guard.ReadyForChallengeRequest")
	proto.RegisterType((*RequestChallengeQuestion)(nil), "guard.RequestChallengeQuestion")
	golang_proto.RegisterType((*RequestChallengeQuestion)(nil), "guard.RequestChallengeQuestion")
	proto.RegisterType((*ResponseChallengeQuestion)(nil), "guard.ResponseChallengeQuestion")
	golang_proto.RegisterType((*ResponseChallengeQuestion)(nil), "guard.ResponseChallengeQuestion")
	proto.RegisterType((*ForceRepairRequest)(nil), "guard.ForceRepairRequest")
	golang_proto.RegisterType((*ForceRepairRequest)(nil), "guard.ForceRepairRequest")
	proto.RegisterType((*Result)(nil), "guard.Result")
	golang_proto.RegisterType((*Result)(nil), "guard.Result")
	proto.RegisterType((*RepairContract)(nil), "guard.RepairContract")
	golang_proto.RegisterType((*RepairContract)(nil), "guard.RepairContract")
	proto.RegisterType((*RepairContractResponse)(nil), "guard.RepairContractResponse")
	golang_proto.RegisterType((*RepairContractResponse)(nil), "guard.RepairContractResponse")
	proto.RegisterType((*RequestRepairContracts)(nil), "guard.RequestRepairContracts")
	golang_proto.RegisterType((*RequestRepairContracts)(nil), "guard.RequestRepairContracts")
	proto.RegisterType((*ResponseRepairContracts)(nil), "guard.ResponseRepairContracts")
	golang_proto.RegisterType((*ResponseRepairContracts)(nil), "guard.ResponseRepairContracts")
}

func init() { proto.RegisterFile("protos/guard/guard.proto", fileDescriptor_ad5b6eccdc9ebee8) }
func init() { golang_proto.RegisterFile("protos/guard/guard.proto", fileDescriptor_ad5b6eccdc9ebee8) }

var fileDescriptor_ad5b6eccdc9ebee8 = []byte{
	// 3075 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x5a, 0xcd, 0x73, 0x1b, 0xc7,
	0xb1, 0xd7, 0xe2, 0x1b, 0x8d, 0xaf, 0xe5, 0x88, 0xa2, 0x40, 0xda, 0x22, 0xf9, 0xe0, 0xb2, 0x2d,
	0xd9, 0xcf, 0x94, 0x9e, 0xac, 0xf2, 0x2b, 0xbf, 0xe7, 0xc4, 0x81, 0x80, 0x25, 0x45, 0x07, 0x02,
	0xe8, 0x05, 0x18, 0x45, 0xae, 0x54, 0x6d, 0xad, 0x80, 0x21, 0xb8, 0x65, 0x70, 0x97, 0xde, 0x5d,
	0x48, 0x96, 0x0f, 0x39, 0xe4, 0x96, 0x4a, 0x55, 0x2a, 0xa7, 0x54, 0xfe, 0x85, 0xe4, 0x98, 0xaa,
	0xe4, 0x18, 0xe7, 0xa8, 0x54, 0x0e, 0x71, 0x2e, 0x39, 0xda, 0xb1, 0xf5, 0x0f, 0x24, 0x37, 0x1f,
	0x53, 0xd3, 0x33, 0xb3, 0x5f, 0x00, 0x41, 0x41, 0x51, 0x55, 0x2e, 0x2c, 0x6c, 0x4f, 0xf7, 0xcc,
	0x74, 0xf7, 0x74, 0xf7, 0xaf, 0x67, 0x08, 0xf5, 0x53, 0xd7, 0xf1, 0x1d, 0xef, 0xfa, 0x78, 0x6a,
	0xba, 0x23, 0xfe, 0x77, 0x07, 0x49, 0x24, 0x8b, 0x1f, 0x1b, 0x37, 0xc6, 0x96, 0x7f, 0x3c, 0x7d,
	0xb0, 0x33, 0x74, 0x4e, 0xae, 0xfb, 0xae, 0x63, 0xbf, 0x35, 0xf5, 0xae, 0x23, 0xc3, 0x83, 0xe9,
	0xd1, 0xf5, 0xb1, 0x33, 0x76, 0xf0, 0x03, 0x7f, 0x71, 0xc1, 0x8d, 0xad, 0xb1, 0xe3, 0x8c, 0x27,
	0x34, 0xe4, 0xf2, 0xad, 0x13, 0xea, 0xf9, 0xe6, 0xc9, 0x29, 0x67, 0x68, 0xfc, 0x4c, 0x81, 0x74,
	0xc7, 0x19, 0x13, 0x0d, 0x4a, 0xc3, 0x63, 0xd3, 0x1e, 0x53, 0x83, 0x71, 0xd4, 0x95, 0x6d, 0xe5,
	0x6a, 0xe9, 0xe6, 0xc6, 0x0e, 0x17, 0xdf, 0x91, 0xe2, 0x3b, 0x03, 0x29, 0x7e, 0xbb, 0xf0, 0xe4,
	0xcb, 0xad, 0x0b, 0xbf, 0xf8, 0x6a, 0x4b, 0xd1, 0x81, 0x0b, 0xb2, 0x21, 0xf2, 0x2a, 0x54, 0x1d,
	0xd7, 0x1a, 0x5b, 0xb6, 0xe9, 0x3b, 0xae, 0x71, 0x6a, 0x8d, 0xea, 0xa9, 0x6d, 0xe5, 0x6a, 0x51,
	0xaf, 0x84, 0xd4, 0x03, 0x6b, 0x44, 0xd6, 0x20, 0xc7, 0x85, 0xea, 0x69, 0x1c, 0x16, 0x5f, 0x8d,
	0xbf, 0x65, 0xa1, 0xdc, 0x72, 0x6c, 0xdf, 0x35, 0x87, 0xfe, 0x5d, 0xea, 0x9b, 0x64, 0x0b, 0x4a,
	0x43, 0xf1, 0x6d, 0x58, 0x23, 0xdc, 0x56, 0x51, 0x07, 0x49, 0xda, 0x1f, 0x91, 0x2b, 0x00, 0x2e,
	0xb5, 0x7d, 0x1a, 0x5d, 0xac, 0xc8, 0x29, 0x6c, 0xa1, 0x75, 0x28, 0x1c, 0x3b, 0x9e, 0x8f, 0x83,
	0x7c, 0xa9, 0x3c, 0xfb, 0x66, 0x43, 0x57, 0x00, 0xbc, 0x63, 0xd3, 0x1d, 0x19, 0xc7, 0xa6, 0x77,
	0x5c, 0xcf, 0x70, 0x49, 0xa4, 0xdc, 0x31, 0xbd, 0x63, 0xb6, 0x32, 0x1f, 0xb6, 0xec, 0x11, 0xfd,
	0xb4, 0x9e, 0xdd, 0x56, 0xae, 0x66, 0x75, 0x2e, 0xb1, 0xcf, 0x28, 0xe4, 0x35, 0xa8, 0x71, 0x86,
	0x23, 0x6b, 0x42, 0x0d, 0xcf, 0xfa, 0x8c, 0xd6, 0x73, 0xdb, 0xca, 0xd5, 0xb4, 0x5e, 0x41, 0xf2,
	0xae, 0x35, 0xa1, 0x7d, 0xeb, 0x33, 0x4a, 0x5e, 0x82, 0x22, 0x72, 0xe0, 0x32, 0x79, 0x5c, 0xa6,
	0xc0, 0x08, 0xb8, 0x4a, 0x8b, 0x6f, 0xdf, 0xf0, 0x7c, 0xd3, 0xf5, 0xeb, 0x85, 0x25, 0xac, 0x8e,
	0x4a, 0xf6, 0x99, 0x18, 0x79, 0x1f, 0x0a, 0x38, 0x09, 0xb5, 0x47, 0xf5, 0xe2, 0x12, 0x53, 0xe4,
	0x99, 0x94, 0x66, 0x8f, 0xd8, 0x16, 0xf1, 0x80, 0xa1, 0x99, 0x80, 0x6f, 0x11, 0x09, 0xc2, 0x4e,
	0xd4, 0x1b, 0xba, 0xce, 0x23, 0x1c, 0x2d, 0x71, 0x3b, 0x71, 0x0a, 0x1b, 0x5e, 0x85, 0xec, 0xa9,
	0x6b, 0x0d, 0x69, 0xbd, 0x8c, 0xca, 0xf3, 0x0f, 0xe6, 0x60, 0xf3, 0xc4, 0x99, 0xda, 0x7e, 0xbd,
	0x82, 0x64, 0xf1, 0x45, 0xde, 0x84, 0x95, 0xa1, 0x33, 0x99, 0x98, 0x3e, 0x75, 0xcd, 0x89, 0x21,
	0x58, 0xaa, 0xc8, 0xa2, 0x86, 0x03, 0x4d, 0xce, 0xac, 0x41, 0xed, 0xd4, 0x7c, 0xec, 0x4c, 0x7d,
	0xc3, 0x1b, 0x1e, 0xd3, 0xd1, 0x74, 0x42, 0xeb, 0xb5, 0x6d, 0xe5, 0x6a, 0xf5, 0xe6, 0xcb, 0x3b,
	0x3c, 0x38, 0xa2, 0x47, 0x65, 0xa7, 0x2f, 0x78, 0xf4, 0x2a, 0x17, 0x92, 0xdf, 0xcc, 0x93, 0xf6,
	0xf4, 0xc4, 0xe0, 0x54, 0xaf, 0xae, 0x72, 0x4f, 0xda, 0xd3, 0x93, 0x03, 0x4e, 0xe1, 0x9b, 0xb2,
	0x7d, 0xcb, 0x1e, 0x33, 0x2b, 0x8a, 0x4d, 0xad, 0xc8, 0x4d, 0xc9, 0x01, 0xbe, 0xa9, 0xc6, 0x2d,
	0x28, 0x04, 0x33, 0x97, 0x20, 0x7f, 0xb7, 0xd7, 0x1d, 0xdc, 0xe9, 0xdc, 0x57, 0x2f, 0x90, 0x0a,
	0x14, 0x3f, 0x3c, 0x6c, 0xea, 0x03, 0x4d, 0xef, 0xdc, 0x57, 0x15, 0x52, 0x86, 0x42, 0xb3, 0xdb,
	0x3d, 0x6c, 0x76, 0x3a, 0xf7, 0xd5, 0x54, 0xe3, 0xf3, 0x22, 0x14, 0xe4, 0x6e, 0xc9, 0xbb, 0x50,
	0x90, 0x27, 0x58, 0x04, 0xda, 0xc5, 0x39, 0x0a, 0x71, 0x47, 0x7d, 0xf1, 0xe5, 0x96, 0xa2, 0x07,
	0xec, 0xe4, 0x6d, 0xc8, 0x7a, 0xbe, 0xe9, 0x53, 0x3c, 0xe9, 0xd5, 0x9b, 0x57, 0x12, 0x72, 0xc1,
	0x8f, 0x3e, 0x63, 0xd2, 0x39, 0x2f, 0xb9, 0x06, 0xaa, 0x88, 0x11, 0xcf, 0x1a, 0xdb, 0xa6, 0x3f,
	0x75, 0x79, 0xdc, 0x95, 0xf5, 0x1a, 0xa7, 0xf7, 0x25, 0x99, 0xc5, 0x2f, 0xc6, 0x4b, 0xc8, 0x98,
	0x41, 0xc6, 0x0a, 0xa3, 0x86, 0x6c, 0x3a, 0x10, 0x71, 0x26, 0x18, 0x23, 0x1d, 0xf1, 0xa4, 0x91,
	0x5d, 0xe2, 0xec, 0xa9, 0x5c, 0xbe, 0x8f, 0xe2, 0x98, 0x3a, 0xae, 0x81, 0x1a, 0x99, 0x93, 0x2f,
	0x9e, 0xe3, 0xbb, 0x0c, 0x79, 0xf9, 0xf2, 0x37, 0x40, 0xe4, 0x1c, 0x63, 0xe2, 0x8c, 0xeb, 0xf9,
	0xed, 0xf4, 0xd5, 0xd2, 0x4d, 0x10, 0xa6, 0xe8, 0x38, 0xe3, 0xdb, 0xd9, 0xdf, 0x7c, 0xb5, 0xa5,
	0xbc, 0xa5, 0x17, 0x39, 0x13, 0x4b, 0x6f, 0x5d, 0x50, 0x27, 0xa6, 0xe7, 0x1b, 0x27, 0xce, 0xc8,
	0x3a, 0x7a, 0xcc, 0xb7, 0xbb, 0x4c, 0xb4, 0x55, 0x99, 0xf4, 0x5d, 0x14, 0xc6, 0xcd, 0xbe, 0x0e,
	0x35, 0x1e, 0x31, 0xe1, 0x5e, 0x8b, 0xb8, 0xd7, 0x2a, 0x92, 0xc3, 0xad, 0xfe, 0x17, 0x94, 0x4f,
	0x5d, 0x7a, 0x6a, 0xba, 0x22, 0x43, 0xf1, 0xe8, 0x2a, 0x49, 0x1a, 0x8b, 0xa0, 0xb7, 0x80, 0x04,
	0x2c, 0xe1, 0x74, 0x25, 0x9c, 0x6e, 0x45, 0x8e, 0x84, 0x33, 0x0e, 0xe1, 0x25, 0x54, 0xc5, 0x9b,
	0x0e, 0x87, 0xd4, 0xf3, 0x8c, 0xe1, 0xb1, 0x39, 0x99, 0xd0, 0x20, 0x73, 0x97, 0x97, 0xd0, 0xaa,
	0xce, 0x26, 0xea, 0xf3, 0x79, 0x5a, 0x72, 0x1a, 0xd4, 0x6f, 0x00, 0x17, 0x71, 0x91, 0xc4, 0xe4,
	0x95, 0x25, 0x26, 0x5f, 0x61, 0x13, 0xc4, 0x67, 0x7d, 0x1d, 0x6a, 0xf1, 0x09, 0x3d, 0x8c, 0xfd,
	0xac, 0x5e, 0x1d, 0x46, 0xf9, 0x3c, 0x72, 0x03, 0x56, 0x43, 0xc6, 0x47, 0xa6, 0x6b, 0x0b, 0xee,
	0x1a, 0x72, 0x93, 0x60, 0xec, 0x9e, 0xe9, 0xda, 0x5c, 0xe2, 0x1d, 0xb8, 0x1c, 0x4a, 0x48, 0xd3,
	0x70, 0x21, 0x1e, 0xf0, 0x97, 0x82, 0x61, 0xa1, 0x30, 0x97, 0xfb, 0x11, 0x5c, 0x3e, 0xb2, 0xdc,
	0x98, 0xa6, 0x42, 0x1a, 0x33, 0xc0, 0xb3, 0x2a, 0x7b, 0x09, 0x27, 0x69, 0x25, 0x96, 0x68, 0x3c,
	0x51, 0xa0, 0x12, 0x0b, 0x49, 0x52, 0x84, 0x6c, 0x5b, 0x6f, 0xee, 0x0e, 0xd4, 0x0b, 0x04, 0x20,
	0xd7, 0xdf, 0xdf, 0xeb, 0x6a, 0x6d, 0x9e, 0x2d, 0x0e, 0x0f, 0x3a, 0xbd, 0x66, 0x5b, 0x6b, 0xab,
	0x29, 0x52, 0x80, 0x4c, 0xa7, 0xd7, 0x1f, 0xa8, 0x69, 0x46, 0x6f, 0x35, 0xbb, 0x2d, 0xad, 0xa3,
	0xb5, 0xd5, 0x0c, 0x93, 0x68, 0x75, 0x7a, 0x7d, 0xad, 0xad, 0x66, 0x59, 0xee, 0xd1, 0xb5, 0xae,
	0x76, 0x4f, 0x6b, 0xab, 0x39, 0xc6, 0xd6, 0xbb, 0xdd, 0xef, 0x75, 0xb4, 0x81, 0xa6, 0xe6, 0x99,
	0xf8, 0xbd, 0xa6, 0xde, 0x55, 0x0b, 0xa4, 0x0a, 0x80, 0xab, 0x19, 0xf8, 0x5d, 0x24, 0x17, 0xa1,
	0xa6, 0x6b, 0xcd, 0xf6, 0x7d, 0xa3, 0x75, 0xa7, 0xd9, 0xe9, 0x68, 0xdd, 0x3d, 0x4d, 0x05, 0x96,
	0xb8, 0x74, 0xad, 0xa5, 0x6b, 0xcd, 0x81, 0xd6, 0x56, 0x4b, 0xe4, 0x12, 0xac, 0xe8, 0xda, 0x87,
	0x87, 0x5a, 0x7f, 0x10, 0xe1, 0x2a, 0x37, 0x7e, 0x9e, 0x82, 0x4b, 0x58, 0xd3, 0x7c, 0xc7, 0xa5,
	0x1d, 0xcb, 0xf3, 0x75, 0xea, 0x9d, 0x3a, 0xb6, 0x47, 0xc9, 0xff, 0x41, 0xde, 0xa5, 0x9f, 0x4c,
	0xa9, 0x27, 0xb3, 0xd9, 0xb6, 0x0c, 0x45, 0xe4, 0x62, 0x09, 0x86, 0x09, 0xee, 0xdb, 0x47, 0x8e,
	0xce, 0xf9, 0x74, 0x29, 0x40, 0xf6, 0xa0, 0x3c, 0x9c, 0xba, 0x58, 0xbd, 0xf0, 0x80, 0xa5, 0x96,
	0xb0, 0x79, 0x49, 0x48, 0xe2, 0xd1, 0x7a, 0x0f, 0x6a, 0xbc, 0x0e, 0xb3, 0xed, 0x19, 0x27, 0xd4,
	0x37, 0xeb, 0x69, 0xcc, 0x0b, 0xab, 0x62, 0x33, 0xc1, 0xde, 0x59, 0x6e, 0xd5, 0x2b, 0x47, 0xd1,
	0x4f, 0x56, 0xc4, 0x86, 0x98, 0xf5, 0x33, 0x78, 0x56, 0xf8, 0x07, 0x79, 0x19, 0x8a, 0x61, 0x3c,
	0x66, 0x31, 0x1e, 0x43, 0x42, 0xe3, 0xf7, 0x59, 0xa8, 0xc4, 0x26, 0x4d, 0x60, 0x11, 0x25, 0x89,
	0x45, 0x62, 0x40, 0x20, 0x95, 0x00, 0x02, 0x72, 0x10, 0x71, 0x44, 0x1a, 0x6b, 0x0f, 0x0e, 0x22,
	0x84, 0x88, 0xa3, 0x84, 0xcc, 0xbf, 0x8f, 0x12, 0xb2, 0xcf, 0x83, 0x12, 0x30, 0x7a, 0xe9, 0xf0,
	0x63, 0xe3, 0x08, 0xbd, 0x67, 0x0f, 0x1f, 0x63, 0x7e, 0xc6, 0xe8, 0xa5, 0xc3, 0x8f, 0x77, 0x25,
	0x35, 0x84, 0x13, 0x47, 0x94, 0x22, 0xe2, 0x49, 0x0b, 0x38, 0xb1, 0x4b, 0x69, 0x04, 0x4e, 0xb0,
	0xd1, 0x02, 0x8e, 0x0a, 0x38, 0xc1, 0x86, 0x03, 0xd8, 0xc5, 0xfd, 0x51, 0x8c, 0xc0, 0xae, 0x16,
	0x3a, 0xe5, 0x55, 0xa8, 0x9e, 0x58, 0xb6, 0x75, 0x32, 0x3d, 0x31, 0x90, 0xea, 0x61, 0x4a, 0xcd,
	0xea, 0x15, 0x41, 0xed, 0x23, 0x91, 0xd5, 0x74, 0x97, 0x0e, 0x9d, 0x87, 0xd4, 0x35, 0xfc, 0x63,
	0x97, 0x7a, 0xc7, 0xce, 0x84, 0x83, 0x97, 0xac, 0xae, 0x8a, 0x81, 0x81, 0xa4, 0x27, 0x20, 0x4e,
	0x39, 0x09, 0x71, 0x62, 0xf0, 0xa8, 0x92, 0x80, 0x47, 0xff, 0x0f, 0x1b, 0x98, 0xa0, 0x12, 0x89,
	0xcd, 0x98, 0x58, 0x27, 0x96, 0x2f, 0xd2, 0xdb, 0x65, 0xc6, 0x11, 0x4b, 0x85, 0x5e, 0x87, 0x0d,
	0x93, 0x26, 0x5c, 0x99, 0x9f, 0xc6, 0xa5, 0x3c, 0x4f, 0x78, 0x1b, 0xde, 0x9c, 0x1c, 0x2d, 0xa6,
	0xc0, 0x54, 0x19, 0xf3, 0x0a, 0x26, 0x4c, 0x91, 0xf5, 0x48, 0xdc, 0x35, 0x2c, 0x5f, 0x36, 0xfe,
	0x94, 0x83, 0x5a, 0x70, 0x70, 0x59, 0x56, 0x9a, 0x7a, 0x64, 0x77, 0x36, 0x7c, 0x78, 0x2c, 0xcf,
	0x0d, 0x9f, 0x08, 0x34, 0x49, 0x04, 0xd2, 0x3b, 0x71, 0x7c, 0xb2, 0x9d, 0x94, 0xe6, 0xcb, 0xed,
	0x30, 0xde, 0x18, 0x44, 0xb9, 0x05, 0x45, 0x89, 0x71, 0x3c, 0x11, 0xb8, 0xb5, 0x04, 0xb6, 0x09,
	0xab, 0xba, 0x64, 0x9c, 0x0b, 0x6c, 0x32, 0xf3, 0x81, 0x8d, 0x0e, 0x84, 0xfb, 0xd0, 0xa5, 0x43,
	0x6a, 0x3d, 0xa4, 0xcf, 0x81, 0x58, 0x50, 0x5e, 0xe7, 0xe2, 0x98, 0x73, 0xe2, 0x30, 0x24, 0xf7,
	0x0c, 0x30, 0x24, 0x99, 0xee, 0xf2, 0xcf, 0x9b, 0xee, 0xe6, 0xe0, 0x8f, 0xc2, 0x5c, 0xfc, 0xa1,
	0x41, 0x99, 0x09, 0x99, 0x13, 0x83, 0xfb, 0xa5, 0x88, 0x7e, 0x69, 0x9c, 0xe1, 0x17, 0x1d, 0x59,
	0xb9, 0x67, 0x4a, 0x6e, 0xf8, 0xf1, 0xe2, 0x61, 0x4c, 0x63, 0x0a, 0xc5, 0xe0, 0x14, 0x44, 0xab,
	0x62, 0x05, 0x8a, 0xbc, 0x12, 0xee, 0x77, 0xf7, 0x54, 0x05, 0xcb, 0xdc, 0x61, 0xb7, 0xcb, 0x3e,
	0x52, 0x44, 0x85, 0xf2, 0x41, 0x53, 0x1f, 0xec, 0x37, 0x3b, 0x86, 0xa8, 0x8f, 0xb2, 0x52, 0x66,
	0xd8, 0xaf, 0x76, 0xaf, 0xab, 0xa9, 0xd9, 0x58, 0xcd, 0xcc, 0xc5, 0xab, 0x5b, 0xbe, 0x71, 0x17,
	0x4a, 0x11, 0x25, 0x49, 0x1e, 0xd2, 0x5d, 0xed, 0x9e, 0x7a, 0x81, 0xd4, 0xa0, 0x24, 0xa7, 0x66,
	0x04, 0x5c, 0x58, 0xfb, 0xe1, 0xc1, 0xbe, 0x8e, 0x05, 0xb9, 0x08, 0x59, 0x2c, 0xb6, 0xbc, 0x22,
	0xcb, 0xf9, 0xd4, 0x4c, 0xe3, 0xd7, 0x0a, 0xac, 0x04, 0x51, 0xf9, 0x21, 0x2b, 0x69, 0x96, 0x63,
	0x27, 0x5a, 0x4b, 0x25, 0xd9, 0x5a, 0x46, 0x9b, 0xd2, 0x54, 0xbc, 0x29, 0x65, 0xfd, 0xee, 0xf1,
	0xd4, 0xfe, 0x58, 0x74, 0x9d, 0x69, 0x9e, 0xfe, 0x90, 0xc4, 0xbb, 0xce, 0x55, 0xc8, 0xda, 0x8e,
	0x3d, 0xa4, 0xa2, 0x61, 0xe5, 0x1f, 0xe4, 0x15, 0xa8, 0xd0, 0x4f, 0x4f, 0xe9, 0xd0, 0x37, 0x4c,
	0xdb, 0x7b, 0x44, 0x5d, 0x3c, 0xd8, 0x45, 0xbd, 0xcc, 0x89, 0x4d, 0xa4, 0x35, 0x7e, 0x92, 0x86,
	0xf5, 0x03, 0xd7, 0x71, 0x8e, 0x7a, 0x47, 0x3a, 0x3d, 0x9d, 0x58, 0x43, 0xd3, 0xa7, 0xc1, 0xde,
	0xc9, 0x77, 0xa1, 0xf0, 0x89, 0xd8, 0xbf, 0x08, 0xfd, 0xba, 0x0c, 0xc0, 0xa4, 0x7e, 0xd1, 0xce,
	0x44, 0xca, 0x90, 0xef, 0x43, 0x35, 0x01, 0x16, 0x97, 0xa9, 0xe5, 0x95, 0x18, 0x00, 0x8c, 0x67,
	0xdc, 0x74, 0x22, 0xe3, 0xce, 0x39, 0xfb, 0x99, 0xb9, 0x67, 0x7f, 0x0b, 0x4a, 0x68, 0xe7, 0x98,
	0x4d, 0x80, 0x91, 0xb8, 0x45, 0xc8, 0x07, 0x91, 0x6e, 0x87, 0xef, 0x39, 0xb7, 0xc4, 0x9e, 0xcb,
	0xb2, 0x27, 0x92, 0x37, 0x1f, 0x89, 0xce, 0x29, 0x3f, 0xa7, 0x73, 0x6a, 0xfc, 0x18, 0xd6, 0x58,
	0xd0, 0xcd, 0xd8, 0xd4, 0x8b, 0xc3, 0x03, 0x25, 0x01, 0x0f, 0xf6, 0xe4, 0x65, 0x83, 0xb4, 0xb7,
	0x57, 0x4f, 0x61, 0xbe, 0xd9, 0x14, 0x4e, 0xc2, 0xb2, 0x37, 0x3b, 0xab, 0x5e, 0x45, 0xb1, 0xe0,
	0xbb, 0xf1, 0x97, 0x14, 0x5c, 0x3e, 0x83, 0x77, 0xf1, 0x0e, 0xe2, 0x67, 0x3a, 0x95, 0x3c, 0xd3,
	0xc9, 0x04, 0x91, 0x9e, 0x4d, 0x10, 0xaf, 0x42, 0x55, 0xee, 0xde, 0x88, 0xa2, 0xad, 0x8a, 0xa4,
	0xf2, 0x02, 0xff, 0x0e, 0x14, 0x43, 0x25, 0xb3, 0xa8, 0xe4, 0x99, 0x27, 0x51, 0x0f, 0x59, 0x59,
	0x6e, 0x15, 0xab, 0x2d, 0xef, 0x4a, 0xb9, 0x4f, 0xf4, 0xe4, 0xfc, 0x44, 0x96, 0x3f, 0x2b, 0x91,
	0x3d, 0x55, 0x60, 0xbd, 0x85, 0x55, 0x36, 0x86, 0x30, 0x05, 0xc0, 0x3d, 0xcf, 0xa6, 0x8b, 0x2e,
	0xaf, 0x5e, 0x81, 0x8a, 0xc0, 0xc9, 0x31, 0xa3, 0x96, 0x03, 0x22, 0x63, 0xda, 0x03, 0xf9, 0xcd,
	0xd5, 0x5e, 0x06, 0x1d, 0x96, 0x84, 0x24, 0xaa, 0xbd, 0x18, 0xed, 0xfe, 0x23, 0x05, 0xeb, 0x67,
	0xe2, 0xf9, 0xf3, 0x90, 0xef, 0x8c, 0x22, 0xa9, 0x39, 0x8a, 0xbc, 0xc1, 0x10, 0x1b, 0x57, 0xe4,
	0xd4, 0x1c, 0x47, 0x90, 0x70, 0x96, 0x55, 0x73, 0x1c, 0x38, 0x30, 0xc7, 0x1c, 0x10, 0xff, 0x37,
	0x90, 0x18, 0x2f, 0xcf, 0x96, 0x19, 0x09, 0xef, 0x02, 0x66, 0x9e, 0x33, 0x93, 0x26, 0x7a, 0xb6,
	0xaa, 0xaf, 0xcc, 0x9a, 0x68, 0xde, 0x2d, 0x42, 0x6e, 0x89, 0xc9, 0x92, 0xb7, 0x08, 0x31, 0x93,
	0xe7, 0x93, 0x26, 0xff, 0x43, 0x06, 0xea, 0xcc, 0xe4, 0x77, 0x1c, 0xcf, 0x97, 0x20, 0xc8, 0x93,
	0x16, 0x8f, 0xd6, 0x10, 0x25, 0x5e, 0x43, 0xfe, 0xc3, 0xd6, 0xbe, 0x0f, 0x6b, 0x49, 0x23, 0x19,
	0x9e, 0xc5, 0x4a, 0xd6, 0x32, 0x76, 0xbf, 0x18, 0x37, 0x55, 0x9f, 0x4d, 0x40, 0xfa, 0xe2, 0x56,
	0x22, 0x3a, 0xb5, 0xef, 0x2c, 0xe5, 0x02, 0x35, 0x3e, 0xef, 0xc0, 0x21, 0x4d, 0x09, 0x59, 0xf3,
	0x08, 0x8d, 0xde, 0x8c, 0x34, 0xaf, 0xf3, 0x2c, 0xbf, 0xd3, 0xa7, 0x13, 0x9a, 0xb8, 0x60, 0x4b,
	0x1e, 0xb0, 0xc2, 0xf3, 0x1e, 0xb0, 0xd8, 0x81, 0x28, 0x26, 0x0f, 0xc4, 0x0e, 0x94, 0x22, 0x8b,
	0x33, 0xec, 0xd2, 0xec, 0x74, 0xf8, 0x45, 0x42, 0xb3, 0x35, 0xd8, 0xff, 0x81, 0xa6, 0x2a, 0x91,
	0x2b, 0x82, 0x54, 0xe3, 0xdb, 0xc8, 0xed, 0x83, 0xc7, 0xf4, 0x21, 0xef, 0x26, 0x5b, 0xf5, 0xad,
	0x73, 0xb4, 0x0d, 0x3b, 0xf5, 0x7d, 0xa8, 0x8c, 0xa9, 0x4d, 0x5d, 0xd3, 0x7f, 0x8e, 0xf2, 0x5e,
	0x96, 0xa2, 0x22, 0xc1, 0x9e, 0x0b, 0xf6, 0xa3, 0x28, 0xff, 0x79, 0x9a, 0xf3, 0xdf, 0xa5, 0xa0,
	0xae, 0x53, 0x73, 0xf4, 0x78, 0xd7, 0x71, 0x83, 0xaa, 0xf1, 0x8c, 0xd9, 0x6a, 0x61, 0x9f, 0x1e,
	0x2f, 0x83, 0xe9, 0x39, 0xaf, 0x06, 0xd1, 0xf7, 0x8a, 0xcc, 0xcc, 0x7b, 0x45, 0x34, 0x6e, 0xb3,
	0xf1, 0xb8, 0x7d, 0x61, 0x05, 0x6c, 0x61, 0x5a, 0x61, 0xea, 0x59, 0x9e, 0xc1, 0xd8, 0x2d, 0x17,
	0x4f, 0x6a, 0x41, 0x2f, 0x58, 0x9e, 0x8e, 0xdf, 0x8d, 0x7f, 0x2a, 0xcc, 0x6e, 0x68, 0xa6, 0x59,
	0x58, 0x7b, 0xeb, 0xd9, 0x21, 0x62, 0x04, 0x18, 0x26, 0xd5, 0x4a, 0xbd, 0x10, 0xb5, 0xd2, 0x0b,
	0xd5, 0xca, 0xc4, 0xd5, 0x8a, 0xbb, 0x34, 0x1b, 0x77, 0x69, 0xe3, 0xa7, 0x29, 0x58, 0x97, 0x97,
	0x59, 0xb3, 0x4a, 0xdf, 0x80, 0x9c, 0xc0, 0x8f, 0xe7, 0xa9, 0x2c, 0xf8, 0x16, 0xc1, 0x7b, 0x4c,
	0x14, 0x9e, 0x33, 0x91, 0xfd, 0x67, 0x7a, 0xb9, 0x62, 0x8d, 0x92, 0xb3, 0xb6, 0xc8, 0x2c, 0xb4,
	0x45, 0x76, 0x91, 0x2d, 0x72, 0x49, 0x5b, 0x28, 0x40, 0x76, 0x1d, 0x77, 0x48, 0x39, 0xf3, 0x8b,
	0x88, 0x98, 0x75, 0x28, 0x98, 0x53, 0xff, 0x38, 0xfa, 0x04, 0xc7, 0xbe, 0x99, 0xdc, 0x42, 0x2d,
	0x1a, 0xbf, 0x54, 0x20, 0xa7, 0x53, 0x6f, 0x3a, 0xf1, 0xc9, 0xeb, 0x90, 0x19, 0x3a, 0x23, 0xfe,
	0x2c, 0x59, 0x0d, 0x5e, 0x4b, 0x02, 0xa7, 0x39, 0x23, 0xaa, 0x23, 0x03, 0xa9, 0x43, 0xfe, 0x84,
	0x7a, 0x9e, 0x39, 0xa6, 0xd2, 0xf4, 0xe2, 0x93, 0xe5, 0x2f, 0x57, 0xf0, 0x2f, 0x6f, 0xfb, 0xb2,
	0x14, 0x65, 0x83, 0x8d, 0x3f, 0x67, 0xa0, 0xca, 0xed, 0x13, 0x3c, 0xe9, 0x2c, 0x84, 0x79, 0xaf,
	0x41, 0x6d, 0x82, 0xad, 0x41, 0x14, 0x3f, 0xa7, 0xaf, 0x16, 0xf5, 0x0a, 0x23, 0xf7, 0x83, 0xe4,
	0xb1, 0xf0, 0x0e, 0xf0, 0x16, 0xac, 0x8d, 0x9c, 0x47, 0xf6, 0xc4, 0x31, 0x47, 0x86, 0x4b, 0x1f,
	0xb1, 0x99, 0xc4, 0x4b, 0x55, 0x06, 0x39, 0x57, 0xe5, 0xa8, 0x8e, 0x83, 0xe2, 0x09, 0xed, 0x06,
	0xac, 0xf2, 0x63, 0x90, 0x90, 0xc9, 0xa2, 0x0c, 0x71, 0x85, 0x97, 0x23, 0x12, 0xe8, 0x6a, 0x94,
	0x60, 0x0e, 0xcb, 0x49, 0x57, 0x33, 0x0a, 0x73, 0x59, 0x17, 0x54, 0x31, 0x1c, 0x36, 0x4d, 0xcb,
	0xdc, 0x62, 0x54, 0xb9, 0x74, 0xd0, 0x36, 0x5d, 0x8b, 0xcd, 0x17, 0xbd, 0xc9, 0xa8, 0x85, 0x9c,
	0xf2, 0xd5, 0x27, 0xd0, 0xd1, 0x88, 0x26, 0xd9, 0x22, 0xee, 0x91, 0xc8, 0xb1, 0x56, 0x98, 0x6c,
	0x11, 0xb8, 0xe0, 0xe4, 0x51, 0x7e, 0x7e, 0x77, 0x21, 0x96, 0x8d, 0x70, 0x77, 0xa2, 0x7d, 0x25,
	0xd7, 0xac, 0xb4, 0x4c, 0x0b, 0x1b, 0x74, 0x9f, 0x67, 0xdd, 0xd0, 0x94, 0xe7, 0x75, 0xa9, 0x8d,
	0xaf, 0x15, 0x58, 0x8b, 0x9f, 0xa6, 0xe0, 0x66, 0xfd, 0x7f, 0x66, 0x1e, 0x0a, 0x2f, 0x05, 0x47,
	0x3f, 0x26, 0x10, 0x3e, 0x10, 0x76, 0x20, 0xe7, 0xe1, 0x5d, 0x8e, 0xb8, 0x81, 0xbb, 0x35, 0x5f,
	0x40, 0xac, 0xb0, 0x93, 0x24, 0xf0, 0x7b, 0x20, 0x5d, 0xcc, 0xd1, 0xd8, 0x85, 0xb5, 0xf9, 0x1c,
	0xa4, 0x06, 0xa5, 0xdb, 0xbd, 0xc1, 0x1d, 0x43, 0xbc, 0x60, 0xe0, 0xbd, 0xcd, 0xbd, 0xe6, 0xfe,
	0xc0, 0xe8, 0xec, 0xf7, 0x07, 0xfc, 0x41, 0x43, 0xd7, 0x3e, 0xd0, 0x5a, 0x03, 0x44, 0x22, 0x7f,
	0x45, 0x1d, 0x39, 0xa2, 0x88, 0x6d, 0xe4, 0x9c, 0xa6, 0x73, 0x0b, 0x4a, 0xc2, 0x81, 0x36, 0x0b,
	0x7f, 0x1e, 0xd2, 0xe2, 0x7c, 0x76, 0x59, 0xbc, 0xcf, 0x3b, 0x8e, 0xe9, 0x17, 0x7c, 0x1c, 0x33,
	0x73, 0x8f, 0x63, 0xe3, 0xb7, 0x69, 0xb8, 0x2c, 0x8d, 0xf2, 0x62, 0x95, 0x7a, 0x5f, 0x22, 0xd2,
	0x34, 0xba, 0xf0, 0x5a, 0x22, 0xdd, 0x25, 0x16, 0x13, 0xae, 0x65, 0x7e, 0x91, 0x78, 0x74, 0x27,
	0x38, 0x04, 0xbc, 0x1b, 0x5c, 0x9b, 0x7f, 0xdd, 0x27, 0xdd, 0x1c, 0xbf, 0x6e, 0xc9, 0x26, 0xae,
	0x5b, 0x9a, 0x3c, 0x49, 0x2f, 0x8f, 0x49, 0x0a, 0xde, 0x82, 0x58, 0xc8, 0xcf, 0x8d, 0x05, 0x03,
	0x20, 0xd4, 0x86, 0x10, 0xa8, 0xb6, 0x7a, 0xdd, 0x81, 0xde, 0x6c, 0x0d, 0x0c, 0x7c, 0xb6, 0x52,
	0x2f, 0x90, 0x4b, 0xb0, 0xd2, 0xee, 0xdd, 0xeb, 0x76, 0x7a, 0xcd, 0xb6, 0xd1, 0xed, 0x0d, 0x0c,
	0xbc, 0xf3, 0x53, 0xc8, 0x0a, 0x54, 0xe4, 0xa3, 0x55, 0x73, 0xaf, 0xb9, 0xdf, 0x55, 0x53, 0xe4,
	0x22, 0xd4, 0x02, 0x69, 0x01, 0x89, 0xd3, 0x6f, 0x0c, 0xa1, 0x1c, 0xad, 0x1a, 0xa4, 0x04, 0xf9,
	0xfe, 0x61, 0xab, 0xa5, 0xf5, 0xfb, 0xea, 0x05, 0xb2, 0x01, 0x6b, 0xec, 0x38, 0x37, 0x07, 0x87,
	0xba, 0x66, 0xec, 0xf6, 0xf4, 0xbb, 0xcd, 0x81, 0xa1, 0xe9, 0x7a, 0x4f, 0x57, 0x15, 0xb2, 0x0e,
	0x97, 0x5a, 0xbd, 0xbb, 0x07, 0x87, 0x03, 0xcd, 0x68, 0xb6, 0xdb, 0xba, 0xd6, 0xef, 0x8b, 0xa1,
	0x14, 0x0b, 0x85, 0xde, 0xe0, 0x8e, 0xa6, 0x0b, 0xc2, 0xea, 0xcd, 0xcf, 0x73, 0x50, 0xde, 0x43,
	0xc5, 0xa8, 0xfb, 0xd0, 0x1a, 0x52, 0xf2, 0x1e, 0x5c, 0xec, 0x4f, 0x1f, 0x9c, 0x58, 0x7e, 0xfc,
	0xbd, 0xe8, 0x0c, 0xb7, 0x6c, 0x54, 0x42, 0x87, 0xb3, 0xe2, 0xf7, 0x1d, 0xa8, 0xf4, 0xa9, 0x1d,
	0xde, 0xe1, 0x90, 0x2b, 0x11, 0xb9, 0xd9, 0x6b, 0x9c, 0xa4, 0x78, 0x17, 0xc8, 0xec, 0xf5, 0x04,
	0xd9, 0x0e, 0x60, 0xcc, 0x19, 0x37, 0x17, 0x1b, 0x67, 0xec, 0x8e, 0xb4, 0x60, 0x65, 0x06, 0x59,
	0x93, 0xad, 0x60, 0xcd, 0xf9, 0x98, 0x3b, 0xb9, 0xa9, 0xff, 0x85, 0x52, 0x04, 0x66, 0x90, 0x75,
	0xb9, 0xd6, 0x0c, 0xf4, 0x48, 0x0a, 0x7e, 0x00, 0x2b, 0x33, 0xbd, 0x0a, 0x39, 0xaf, 0x8b, 0xd9,
	0x58, 0x4d, 0xb4, 0x17, 0xbc, 0x1b, 0xd2, 0x41, 0xd5, 0xa9, 0xef, 0x5a, 0xf4, 0x21, 0x95, 0x17,
	0x1a, 0xe4, 0xdc, 0xb7, 0xcb, 0x8d, 0x97, 0x93, 0x76, 0x89, 0x3d, 0x86, 0x0e, 0xd8, 0x9c, 0x71,
	0xfc, 0x7c, 0xbe, 0x71, 0x42, 0x86, 0x33, 0x90, 0x77, 0x9b, 0xd9, 0x3c, 0x81, 0x50, 0x83, 0xad,
	0x9e, 0x89, 0x5d, 0x93, 0xb6, 0xeb, 0xc0, 0x2a, 0x3f, 0x86, 0x09, 0xf0, 0x32, 0xbf, 0xa8, 0x6c,
	0x5c, 0x59, 0x58, 0x3a, 0xc8, 0x47, 0x0c, 0x35, 0xe3, 0x7e, 0x77, 0x1d, 0x37, 0x99, 0x00, 0xaf,
	0xc4, 0x35, 0x4a, 0x0c, 0x6f, 0x6c, 0x2e, 0x4e, 0x69, 0xb7, 0xbf, 0xf7, 0xed, 0xd7, 0x9b, 0xca,
	0x93, 0x6f, 0x36, 0x95, 0x2f, 0xbe, 0xd9, 0x54, 0xfe, 0xfe, 0xcd, 0xa6, 0xf2, 0xab, 0xa7, 0x9b,
	0xca, 0x1f, 0x9f, 0x6e, 0x2a, 0x4f, 0x9e, 0x6e, 0x2a, 0x50, 0xb1, 0x9c, 0x9d, 0x07, 0xfe, 0x91,
	0xc7, 0x27, 0xb9, 0x0d, 0x18, 0x6b, 0x07, 0x2c, 0x15, 0x1d, 0x28, 0x1f, 0xf1, 0x7f, 0x95, 0x7b,
	0x90, 0xc3, 0xd4, 0xf4, 0xf6, 0xbf, 0x02, 0x00, 0x00, 0xff, 0xff, 0x28, 0xee, 0x44, 0x62, 0x54,
	0x27, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// GuardServiceClient is the client API for GuardService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type GuardServiceClient interface {
	SubmitFileStoreMeta(ctx context.Context, in *FileStoreStatus, opts ...grpc.CallOption) (*Result, error)
	SendQuestions(ctx context.Context, in *FileChallengeQuestions, opts ...grpc.CallOption) (*Result, error)
	CheckFileStoreMeta(ctx context.Context, in *CheckFileStoreMetaRequest, opts ...grpc.CallOption) (*FileStoreStatus, error)
	ReadyForChallenge(ctx context.Context, in *ReadyForChallengeRequest, opts ...grpc.CallOption) (*Result, error)
	ForceRepair(ctx context.Context, in *ForceRepairRequest, opts ...grpc.CallOption) (*Result, error)
	ListHostContracts(ctx context.Context, in *ListHostContractsRequest, opts ...grpc.CallOption) (*ContractsList, error)
	RetrieveFileInfo(ctx context.Context, in *ListRenterFileInfoRequest, opts ...grpc.CallOption) (*FileStoreListResponse, error)
	RequestChallenge(ctx context.Context, in *ReadyForChallengeRequest, opts ...grpc.CallOption) (*RequestChallengeQuestion, error)
	ResponseChallenge(ctx context.Context, in *ResponseChallengeQuestion, opts ...grpc.CallOption) (*Result, error)
	SubmitRepairContract(ctx context.Context, in *RepairContract, opts ...grpc.CallOption) (*RepairContractResponse, error)
	RequestForRepairContracts(ctx context.Context, in *RequestRepairContracts, opts ...grpc.CallOption) (*ResponseRepairContracts, error)
}

type guardServiceClient struct {
	cc *grpc.ClientConn
}

func NewGuardServiceClient(cc *grpc.ClientConn) GuardServiceClient {
	return &guardServiceClient{cc}
}

func (c *guardServiceClient) SubmitFileStoreMeta(ctx context.Context, in *FileStoreStatus, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/guard.GuardService/SubmitFileStoreMeta", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guardServiceClient) SendQuestions(ctx context.Context, in *FileChallengeQuestions, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/guard.GuardService/SendQuestions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guardServiceClient) CheckFileStoreMeta(ctx context.Context, in *CheckFileStoreMetaRequest, opts ...grpc.CallOption) (*FileStoreStatus, error) {
	out := new(FileStoreStatus)
	err := c.cc.Invoke(ctx, "/guard.GuardService/CheckFileStoreMeta", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guardServiceClient) ReadyForChallenge(ctx context.Context, in *ReadyForChallengeRequest, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/guard.GuardService/ReadyForChallenge", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guardServiceClient) ForceRepair(ctx context.Context, in *ForceRepairRequest, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/guard.GuardService/ForceRepair", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guardServiceClient) ListHostContracts(ctx context.Context, in *ListHostContractsRequest, opts ...grpc.CallOption) (*ContractsList, error) {
	out := new(ContractsList)
	err := c.cc.Invoke(ctx, "/guard.GuardService/ListHostContracts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guardServiceClient) RetrieveFileInfo(ctx context.Context, in *ListRenterFileInfoRequest, opts ...grpc.CallOption) (*FileStoreListResponse, error) {
	out := new(FileStoreListResponse)
	err := c.cc.Invoke(ctx, "/guard.GuardService/RetrieveFileInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guardServiceClient) RequestChallenge(ctx context.Context, in *ReadyForChallengeRequest, opts ...grpc.CallOption) (*RequestChallengeQuestion, error) {
	out := new(RequestChallengeQuestion)
	err := c.cc.Invoke(ctx, "/guard.GuardService/RequestChallenge", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guardServiceClient) ResponseChallenge(ctx context.Context, in *ResponseChallengeQuestion, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/guard.GuardService/ResponseChallenge", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guardServiceClient) SubmitRepairContract(ctx context.Context, in *RepairContract, opts ...grpc.CallOption) (*RepairContractResponse, error) {
	out := new(RepairContractResponse)
	err := c.cc.Invoke(ctx, "/guard.GuardService/SubmitRepairContract", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guardServiceClient) RequestForRepairContracts(ctx context.Context, in *RequestRepairContracts, opts ...grpc.CallOption) (*ResponseRepairContracts, error) {
	out := new(ResponseRepairContracts)
	err := c.cc.Invoke(ctx, "/guard.GuardService/RequestForRepairContracts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GuardServiceServer is the server API for GuardService service.
type GuardServiceServer interface {
	SubmitFileStoreMeta(context.Context, *FileStoreStatus) (*Result, error)
	SendQuestions(context.Context, *FileChallengeQuestions) (*Result, error)
	CheckFileStoreMeta(context.Context, *CheckFileStoreMetaRequest) (*FileStoreStatus, error)
	ReadyForChallenge(context.Context, *ReadyForChallengeRequest) (*Result, error)
	ForceRepair(context.Context, *ForceRepairRequest) (*Result, error)
	ListHostContracts(context.Context, *ListHostContractsRequest) (*ContractsList, error)
	RetrieveFileInfo(context.Context, *ListRenterFileInfoRequest) (*FileStoreListResponse, error)
	RequestChallenge(context.Context, *ReadyForChallengeRequest) (*RequestChallengeQuestion, error)
	ResponseChallenge(context.Context, *ResponseChallengeQuestion) (*Result, error)
	SubmitRepairContract(context.Context, *RepairContract) (*RepairContractResponse, error)
	RequestForRepairContracts(context.Context, *RequestRepairContracts) (*ResponseRepairContracts, error)
}

// UnimplementedGuardServiceServer can be embedded to have forward compatible implementations.
type UnimplementedGuardServiceServer struct {
}

func (*UnimplementedGuardServiceServer) SubmitFileStoreMeta(ctx context.Context, req *FileStoreStatus) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitFileStoreMeta not implemented")
}
func (*UnimplementedGuardServiceServer) SendQuestions(ctx context.Context, req *FileChallengeQuestions) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendQuestions not implemented")
}
func (*UnimplementedGuardServiceServer) CheckFileStoreMeta(ctx context.Context, req *CheckFileStoreMetaRequest) (*FileStoreStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckFileStoreMeta not implemented")
}
func (*UnimplementedGuardServiceServer) ReadyForChallenge(ctx context.Context, req *ReadyForChallengeRequest) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadyForChallenge not implemented")
}
func (*UnimplementedGuardServiceServer) ForceRepair(ctx context.Context, req *ForceRepairRequest) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ForceRepair not implemented")
}
func (*UnimplementedGuardServiceServer) ListHostContracts(ctx context.Context, req *ListHostContractsRequest) (*ContractsList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListHostContracts not implemented")
}
func (*UnimplementedGuardServiceServer) RetrieveFileInfo(ctx context.Context, req *ListRenterFileInfoRequest) (*FileStoreListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RetrieveFileInfo not implemented")
}
func (*UnimplementedGuardServiceServer) RequestChallenge(ctx context.Context, req *ReadyForChallengeRequest) (*RequestChallengeQuestion, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestChallenge not implemented")
}
func (*UnimplementedGuardServiceServer) ResponseChallenge(ctx context.Context, req *ResponseChallengeQuestion) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResponseChallenge not implemented")
}
func (*UnimplementedGuardServiceServer) SubmitRepairContract(ctx context.Context, req *RepairContract) (*RepairContractResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitRepairContract not implemented")
}
func (*UnimplementedGuardServiceServer) RequestForRepairContracts(ctx context.Context, req *RequestRepairContracts) (*ResponseRepairContracts, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestForRepairContracts not implemented")
}

func RegisterGuardServiceServer(s *grpc.Server, srv GuardServiceServer) {
	s.RegisterService(&_GuardService_serviceDesc, srv)
}

func _GuardService_SubmitFileStoreMeta_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileStoreStatus)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuardServiceServer).SubmitFileStoreMeta(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/guard.GuardService/SubmitFileStoreMeta",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuardServiceServer).SubmitFileStoreMeta(ctx, req.(*FileStoreStatus))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuardService_SendQuestions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileChallengeQuestions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuardServiceServer).SendQuestions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/guard.GuardService/SendQuestions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuardServiceServer).SendQuestions(ctx, req.(*FileChallengeQuestions))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuardService_CheckFileStoreMeta_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckFileStoreMetaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuardServiceServer).CheckFileStoreMeta(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/guard.GuardService/CheckFileStoreMeta",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuardServiceServer).CheckFileStoreMeta(ctx, req.(*CheckFileStoreMetaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuardService_ReadyForChallenge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadyForChallengeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuardServiceServer).ReadyForChallenge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/guard.GuardService/ReadyForChallenge",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuardServiceServer).ReadyForChallenge(ctx, req.(*ReadyForChallengeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuardService_ForceRepair_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ForceRepairRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuardServiceServer).ForceRepair(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/guard.GuardService/ForceRepair",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuardServiceServer).ForceRepair(ctx, req.(*ForceRepairRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuardService_ListHostContracts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListHostContractsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuardServiceServer).ListHostContracts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/guard.GuardService/ListHostContracts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuardServiceServer).ListHostContracts(ctx, req.(*ListHostContractsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuardService_RetrieveFileInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRenterFileInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuardServiceServer).RetrieveFileInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/guard.GuardService/RetrieveFileInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuardServiceServer).RetrieveFileInfo(ctx, req.(*ListRenterFileInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuardService_RequestChallenge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadyForChallengeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuardServiceServer).RequestChallenge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/guard.GuardService/RequestChallenge",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuardServiceServer).RequestChallenge(ctx, req.(*ReadyForChallengeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuardService_ResponseChallenge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResponseChallengeQuestion)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuardServiceServer).ResponseChallenge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/guard.GuardService/ResponseChallenge",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuardServiceServer).ResponseChallenge(ctx, req.(*ResponseChallengeQuestion))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuardService_SubmitRepairContract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RepairContract)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuardServiceServer).SubmitRepairContract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/guard.GuardService/SubmitRepairContract",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuardServiceServer).SubmitRepairContract(ctx, req.(*RepairContract))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuardService_RequestForRepairContracts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestRepairContracts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuardServiceServer).RequestForRepairContracts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/guard.GuardService/RequestForRepairContracts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuardServiceServer).RequestForRepairContracts(ctx, req.(*RequestRepairContracts))
	}
	return interceptor(ctx, in, info, handler)
}

var _GuardService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "guard.GuardService",
	HandlerType: (*GuardServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SubmitFileStoreMeta",
			Handler:    _GuardService_SubmitFileStoreMeta_Handler,
		},
		{
			MethodName: "SendQuestions",
			Handler:    _GuardService_SendQuestions_Handler,
		},
		{
			MethodName: "CheckFileStoreMeta",
			Handler:    _GuardService_CheckFileStoreMeta_Handler,
		},
		{
			MethodName: "ReadyForChallenge",
			Handler:    _GuardService_ReadyForChallenge_Handler,
		},
		{
			MethodName: "ForceRepair",
			Handler:    _GuardService_ForceRepair_Handler,
		},
		{
			MethodName: "ListHostContracts",
			Handler:    _GuardService_ListHostContracts_Handler,
		},
		{
			MethodName: "RetrieveFileInfo",
			Handler:    _GuardService_RetrieveFileInfo_Handler,
		},
		{
			MethodName: "RequestChallenge",
			Handler:    _GuardService_RequestChallenge_Handler,
		},
		{
			MethodName: "ResponseChallenge",
			Handler:    _GuardService_ResponseChallenge_Handler,
		},
		{
			MethodName: "SubmitRepairContract",
			Handler:    _GuardService_SubmitRepairContract_Handler,
		},
		{
			MethodName: "RequestForRepairContracts",
			Handler:    _GuardService_RequestForRepairContracts_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "protos/guard/guard.proto",
}

func (m *Log) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Log) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Log) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Change) > 0 {
		i -= len(m.Change)
		copy(dAtA[i:], m.Change)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.Change)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.OriginatorPid) > 0 {
		i -= len(m.OriginatorPid)
		copy(dAtA[i:], m.OriginatorPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.OriginatorPid)))
		i--
		dAtA[i] = 0x12
	}
	n1, err1 := github_com_tron_us_protobuf_types.StdTimeMarshalTo(m.ChangeTime, dAtA[i-github_com_tron_us_protobuf_types.SizeOfStdTime(m.ChangeTime):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintGuard(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ContractMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContractMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContractMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ContingentAmount != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.ContingentAmount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.NumPayouts != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.NumPayouts))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.PayoutSchedule != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.PayoutSchedule))
		i--
		dAtA[i] = 0x78
	}
	if m.CollateralAmount != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.CollateralAmount))
		i--
		dAtA[i] = 0x70
	}
	if m.Amount != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.Amount))
		i--
		dAtA[i] = 0x68
	}
	if m.Price != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.Price))
		i--
		dAtA[i] = 0x60
	}
	if len(m.EscrowPid) > 0 {
		i -= len(m.EscrowPid)
		copy(dAtA[i:], m.EscrowPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.EscrowPid)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.GuardPid) > 0 {
		i -= len(m.GuardPid)
		copy(dAtA[i:], m.GuardPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.GuardPid)))
		i--
		dAtA[i] = 0x52
	}
	n2, err2 := github_com_tron_us_protobuf_types.StdTimeMarshalTo(m.RentEnd, dAtA[i-github_com_tron_us_protobuf_types.SizeOfStdTime(m.RentEnd):])
	if err2 != nil {
		return 0, err2
	}
	i -= n2
	i = encodeVarintGuard(dAtA, i, uint64(n2))
	i--
	dAtA[i] = 0x4a
	n3, err3 := github_com_tron_us_protobuf_types.StdTimeMarshalTo(m.RentStart, dAtA[i-github_com_tron_us_protobuf_types.SizeOfStdTime(m.RentStart):])
	if err3 != nil {
		return 0, err3
	}
	i -= n3
	i = encodeVarintGuard(dAtA, i, uint64(n3))
	i--
	dAtA[i] = 0x42
	if len(m.FileHash) > 0 {
		i -= len(m.FileHash)
		copy(dAtA[i:], m.FileHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.FileHash)))
		i--
		dAtA[i] = 0x3a
	}
	if m.ShardFileSize != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.ShardFileSize))
		i--
		dAtA[i] = 0x30
	}
	if m.ShardIndex != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.ShardIndex))
		i--
		dAtA[i] = 0x28
	}
	if len(m.ShardHash) > 0 {
		i -= len(m.ShardHash)
		copy(dAtA[i:], m.ShardHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.ShardHash)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.HostPid) > 0 {
		i -= len(m.HostPid)
		copy(dAtA[i:], m.HostPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.HostPid)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RenterPid) > 0 {
		i -= len(m.RenterPid)
		copy(dAtA[i:], m.RenterPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.RenterPid)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Contract) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Contract) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Contract) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	n4, err4 := github_com_tron_us_protobuf_types.StdTimeMarshalTo(m.FirstChallengeSuccess, dAtA[i-github_com_tron_us_protobuf_types.SizeOfStdTime(m.FirstChallengeSuccess):])
	if err4 != nil {
		return 0, err4
	}
	i -= n4
	i = encodeVarintGuard(dAtA, i, uint64(n4))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x8a
	if m.ChallengeSuccessTimes != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.ChallengeSuccessTimes))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.ChallengeWarnTimes != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.ChallengeWarnTimes))
		i--
		dAtA[i] = 0x78
	}
	if m.ChallengeTimes != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.ChallengeTimes))
		i--
		dAtA[i] = 0x70
	}
	n5, err5 := github_com_tron_us_protobuf_types.StdTimeMarshalTo(m.LastChallengeTime, dAtA[i-github_com_tron_us_protobuf_types.SizeOfStdTime(m.LastChallengeTime):])
	if err5 != nil {
		return 0, err5
	}
	i -= n5
	i = encodeVarintGuard(dAtA, i, uint64(n5))
	i--
	dAtA[i] = 0x6a
	n6, err6 := github_com_tron_us_protobuf_types.StdTimeMarshalTo(m.LastSuccessChallengeTime, dAtA[i-github_com_tron_us_protobuf_types.SizeOfStdTime(m.LastSuccessChallengeTime):])
	if err6 != nil {
		return 0, err6
	}
	i -= n6
	i = encodeVarintGuard(dAtA, i, uint64(n6))
	i--
	dAtA[i] = 0x62
	if len(m.PreparerSignature) > 0 {
		i -= len(m.PreparerSignature)
		copy(dAtA[i:], m.PreparerSignature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.PreparerSignature)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.PreparerPid) > 0 {
		i -= len(m.PreparerPid)
		copy(dAtA[i:], m.PreparerPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.PreparerPid)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.GuardSignature) > 0 {
		i -= len(m.GuardSignature)
		copy(dAtA[i:], m.GuardSignature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.GuardSignature)))
		i--
		dAtA[i] = 0x4a
	}
	n7, err7 := github_com_tron_us_protobuf_types.StdTimeMarshalTo(m.LastModifyTime, dAtA[i-github_com_tron_us_protobuf_types.SizeOfStdTime(m.LastModifyTime):])
	if err7 != nil {
		return 0, err7
	}
	i -= n7
	i = encodeVarintGuard(dAtA, i, uint64(n7))
	i--
	dAtA[i] = 0x42
	if len(m.ChangeLog) > 0 {
		for iNdEx := len(m.ChangeLog) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ChangeLog[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGuard(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.EscrowSignature) > 0 {
		i -= len(m.EscrowSignature)
		copy(dAtA[i:], m.EscrowSignature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.EscrowSignature)))
		i--
		dAtA[i] = 0x32
	}
	n8, err8 := github_com_tron_us_protobuf_types.StdTimeMarshalTo(m.EscrowSignedTime, dAtA[i-github_com_tron_us_protobuf_types.SizeOfStdTime(m.EscrowSignedTime):])
	if err8 != nil {
		return 0, err8
	}
	i -= n8
	i = encodeVarintGuard(dAtA, i, uint64(n8))
	i--
	dAtA[i] = 0x2a
	if len(m.HostSignature) > 0 {
		i -= len(m.HostSignature)
		copy(dAtA[i:], m.HostSignature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.HostSignature)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.RenterSignature) > 0 {
		i -= len(m.RenterSignature)
		copy(dAtA[i:], m.RenterSignature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.RenterSignature)))
		i--
		dAtA[i] = 0x1a
	}
	if m.State != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.ContractMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGuard(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *FileStoreListResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileStoreListResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileStoreListResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Count != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x20
	}
	if len(m.FileStoreMeta) > 0 {
		for iNdEx := len(m.FileStoreMeta) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FileStoreMeta[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGuard(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	n10, err10 := github_com_tron_us_protobuf_types.StdTimeMarshalTo(m.CurrentTime, dAtA[i-github_com_tron_us_protobuf_types.SizeOfStdTime(m.CurrentTime):])
	if err10 != nil {
		return 0, err10
	}
	i -= n10
	i = encodeVarintGuard(dAtA, i, uint64(n10))
	i--
	dAtA[i] = 0x12
	if m.Request != nil {
		{
			size, err := m.Request.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGuard(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FileStoreMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileStoreMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileStoreMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CheckFrequencyWarn != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.CheckFrequencyWarn))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.SuccessChallengeTimesLimit != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.SuccessChallengeTimesLimit))
		i--
		dAtA[i] = 0x78
	}
	if m.WarnChallengeTimesLimit != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.WarnChallengeTimesLimit))
		i--
		dAtA[i] = 0x70
	}
	if len(m.GuardPid) > 0 {
		i -= len(m.GuardPid)
		copy(dAtA[i:], m.GuardPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.GuardPid)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.EscrowPid) > 0 {
		i -= len(m.EscrowPid)
		copy(dAtA[i:], m.EscrowPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.EscrowPid)))
		i--
		dAtA[i] = 0x62
	}
	if m.RecoverThreshold != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.RecoverThreshold))
		i--
		dAtA[i] = 0x58
	}
	if m.MinimumShards != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.MinimumShards))
		i--
		dAtA[i] = 0x50
	}
	if m.ShardCount != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.ShardCount))
		i--
		dAtA[i] = 0x48
	}
	if m.EscrowFee != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.EscrowFee))
		i--
		dAtA[i] = 0x40
	}
	if m.GuardFee != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.GuardFee))
		i--
		dAtA[i] = 0x38
	}
	if m.CheckFrequency != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.CheckFrequency))
		i--
		dAtA[i] = 0x30
	}
	n12, err12 := github_com_tron_us_protobuf_types.StdTimeMarshalTo(m.RentEnd, dAtA[i-github_com_tron_us_protobuf_types.SizeOfStdTime(m.RentEnd):])
	if err12 != nil {
		return 0, err12
	}
	i -= n12
	i = encodeVarintGuard(dAtA, i, uint64(n12))
	i--
	dAtA[i] = 0x2a
	n13, err13 := github_com_tron_us_protobuf_types.StdTimeMarshalTo(m.RentStart, dAtA[i-github_com_tron_us_protobuf_types.SizeOfStdTime(m.RentStart):])
	if err13 != nil {
		return 0, err13
	}
	i -= n13
	i = encodeVarintGuard(dAtA, i, uint64(n13))
	i--
	dAtA[i] = 0x22
	if m.FileSize != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.FileSize))
		i--
		dAtA[i] = 0x18
	}
	if len(m.FileHash) > 0 {
		i -= len(m.FileHash)
		copy(dAtA[i:], m.FileHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.FileHash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RenterPid) > 0 {
		i -= len(m.RenterPid)
		copy(dAtA[i:], m.RenterPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.RenterPid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FileStoreStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileStoreStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileStoreStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PreparerSignature) > 0 {
		i -= len(m.PreparerSignature)
		copy(dAtA[i:], m.PreparerSignature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.PreparerSignature)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.PreparerPid) > 0 {
		i -= len(m.PreparerPid)
		copy(dAtA[i:], m.PreparerPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.PreparerPid)))
		i--
		dAtA[i] = 0x52
	}
	if m.RentalState != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.RentalState))
		i--
		dAtA[i] = 0x48
	}
	if len(m.GuardSignature) > 0 {
		i -= len(m.GuardSignature)
		copy(dAtA[i:], m.GuardSignature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.GuardSignature)))
		i--
		dAtA[i] = 0x42
	}
	n14, err14 := github_com_tron_us_protobuf_types.StdTimeMarshalTo(m.CurrentTime, dAtA[i-github_com_tron_us_protobuf_types.SizeOfStdTime(m.CurrentTime):])
	if err14 != nil {
		return 0, err14
	}
	i -= n14
	i = encodeVarintGuard(dAtA, i, uint64(n14))
	i--
	dAtA[i] = 0x3a
	if len(m.ChangeLog) > 0 {
		for iNdEx := len(m.ChangeLog) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ChangeLog[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGuard(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	n15, err15 := github_com_tron_us_protobuf_types.StdTimeMarshalTo(m.GuardReceiveTime, dAtA[i-github_com_tron_us_protobuf_types.SizeOfStdTime(m.GuardReceiveTime):])
	if err15 != nil {
		return 0, err15
	}
	i -= n15
	i = encodeVarintGuard(dAtA, i, uint64(n15))
	i--
	dAtA[i] = 0x2a
	if len(m.RenterSignature) > 0 {
		i -= len(m.RenterSignature)
		copy(dAtA[i:], m.RenterSignature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.RenterSignature)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Contracts) > 0 {
		for iNdEx := len(m.Contracts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Contracts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGuard(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.State != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.FileStoreMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGuard(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ChallengeQuestion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChallengeQuestion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChallengeQuestion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ExpectAnswer) > 0 {
		i -= len(m.ExpectAnswer)
		copy(dAtA[i:], m.ExpectAnswer)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.ExpectAnswer)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Nonce) > 0 {
		i -= len(m.Nonce)
		copy(dAtA[i:], m.Nonce)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.Nonce)))
		i--
		dAtA[i] = 0x22
	}
	if m.ChunkIndex != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.ChunkIndex))
		i--
		dAtA[i] = 0x18
	}
	if len(m.HostPid) > 0 {
		i -= len(m.HostPid)
		copy(dAtA[i:], m.HostPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.HostPid)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ShardHash) > 0 {
		i -= len(m.ShardHash)
		copy(dAtA[i:], m.ShardHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.ShardHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProofOfReplicateChallenge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProofOfReplicateChallenge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProofOfReplicateChallenge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.HostSignature) > 0 {
		i -= len(m.HostSignature)
		copy(dAtA[i:], m.HostSignature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.HostSignature)))
		i--
		dAtA[i] = 0x3a
	}
	n17, err17 := github_com_tron_us_protobuf_types.StdTimeMarshalTo(m.HostSignTime, dAtA[i-github_com_tron_us_protobuf_types.SizeOfStdTime(m.HostSignTime):])
	if err17 != nil {
		return 0, err17
	}
	i -= n17
	i = encodeVarintGuard(dAtA, i, uint64(n17))
	i--
	dAtA[i] = 0x32
	if len(m.HostAnswer) > 0 {
		i -= len(m.HostAnswer)
		copy(dAtA[i:], m.HostAnswer)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.HostAnswer)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.GuardSignature) > 0 {
		i -= len(m.GuardSignature)
		copy(dAtA[i:], m.GuardSignature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.GuardSignature)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.GuardPid) > 0 {
		i -= len(m.GuardPid)
		copy(dAtA[i:], m.GuardPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.GuardPid)))
		i--
		dAtA[i] = 0x1a
	}
	n18, err18 := github_com_tron_us_protobuf_types.StdTimeMarshalTo(m.ChallengeTime, dAtA[i-github_com_tron_us_protobuf_types.SizeOfStdTime(m.ChallengeTime):])
	if err18 != nil {
		return 0, err18
	}
	i -= n18
	i = encodeVarintGuard(dAtA, i, uint64(n18))
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ChallengeQuestion.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGuard(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *FileChallengeQuestions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileChallengeQuestions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileChallengeQuestions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ShardQuestions) > 0 {
		for iNdEx := len(m.ShardQuestions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ShardQuestions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGuard(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.FileHash) > 0 {
		i -= len(m.FileHash)
		copy(dAtA[i:], m.FileHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.FileHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ShardChallengeQuestions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardChallengeQuestions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShardChallengeQuestions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PreparerSignature) > 0 {
		i -= len(m.PreparerSignature)
		copy(dAtA[i:], m.PreparerSignature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.PreparerSignature)))
		i--
		dAtA[i] = 0x3a
	}
	n20, err20 := github_com_tron_us_protobuf_types.StdTimeMarshalTo(m.PrepareTime, dAtA[i-github_com_tron_us_protobuf_types.SizeOfStdTime(m.PrepareTime):])
	if err20 != nil {
		return 0, err20
	}
	i -= n20
	i = encodeVarintGuard(dAtA, i, uint64(n20))
	i--
	dAtA[i] = 0x32
	if len(m.Questions) > 0 {
		for iNdEx := len(m.Questions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Questions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGuard(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.QuestionCount != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.QuestionCount))
		i--
		dAtA[i] = 0x20
	}
	if len(m.PreparerPid) > 0 {
		i -= len(m.PreparerPid)
		copy(dAtA[i:], m.PreparerPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.PreparerPid)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ShardHash) > 0 {
		i -= len(m.ShardHash)
		copy(dAtA[i:], m.ShardHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.ShardHash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FileHash) > 0 {
		i -= len(m.FileHash)
		copy(dAtA[i:], m.FileHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.FileHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CheckFileStoreMetaRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckFileStoreMetaRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckFileStoreMetaRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x2a
	}
	n21, err21 := github_com_tron_us_protobuf_types.StdTimeMarshalTo(m.RequestTime, dAtA[i-github_com_tron_us_protobuf_types.SizeOfStdTime(m.RequestTime):])
	if err21 != nil {
		return 0, err21
	}
	i -= n21
	i = encodeVarintGuard(dAtA, i, uint64(n21))
	i--
	dAtA[i] = 0x22
	if len(m.RequesterPid) > 0 {
		i -= len(m.RequesterPid)
		copy(dAtA[i:], m.RequesterPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.RequesterPid)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RenterPid) > 0 {
		i -= len(m.RenterPid)
		copy(dAtA[i:], m.RenterPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.RenterPid)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FileHash) > 0 {
		i -= len(m.FileHash)
		copy(dAtA[i:], m.FileHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.FileHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListRenterFileInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListRenterFileInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListRenterFileInfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x3a
	}
	if m.LastModifyTime != nil {
		n22, err22 := github_com_tron_us_protobuf_types.StdTimeMarshalTo(*m.LastModifyTime, dAtA[i-github_com_tron_us_protobuf_types.SizeOfStdTime(*m.LastModifyTime):])
		if err22 != nil {
			return 0, err22
		}
		i -= n22
		i = encodeVarintGuard(dAtA, i, uint64(n22))
		i--
		dAtA[i] = 0x32
	}
	if m.RequestTime != nil {
		n23, err23 := github_com_tron_us_protobuf_types.StdTimeMarshalTo(*m.RequestTime, dAtA[i-github_com_tron_us_protobuf_types.SizeOfStdTime(*m.RequestTime):])
		if err23 != nil {
			return 0, err23
		}
		i -= n23
		i = encodeVarintGuard(dAtA, i, uint64(n23))
		i--
		dAtA[i] = 0x2a
	}
	if m.RequestPageIndex != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.RequestPageIndex))
		i--
		dAtA[i] = 0x20
	}
	if m.RequestPageSize != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.RequestPageSize))
		i--
		dAtA[i] = 0x18
	}
	if len(m.RequesterPid) > 0 {
		i -= len(m.RequesterPid)
		copy(dAtA[i:], m.RequesterPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.RequesterPid)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RenterPid) > 0 {
		i -= len(m.RenterPid)
		copy(dAtA[i:], m.RenterPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.RenterPid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListHostContractsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListHostContractsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListHostContractsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x4a
	}
	if m.RequestTime != nil {
		n24, err24 := github_com_tron_us_protobuf_types.StdTimeMarshalTo(*m.RequestTime, dAtA[i-github_com_tron_us_protobuf_types.SizeOfStdTime(*m.RequestTime):])
		if err24 != nil {
			return 0, err24
		}
		i -= n24
		i = encodeVarintGuard(dAtA, i, uint64(n24))
		i--
		dAtA[i] = 0x42
	}
	if m.State != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x38
	}
	if m.LastModifyTimeTo != nil {
		n25, err25 := github_com_tron_us_protobuf_types.StdTimeMarshalTo(*m.LastModifyTimeTo, dAtA[i-github_com_tron_us_protobuf_types.SizeOfStdTime(*m.LastModifyTimeTo):])
		if err25 != nil {
			return 0, err25
		}
		i -= n25
		i = encodeVarintGuard(dAtA, i, uint64(n25))
		i--
		dAtA[i] = 0x32
	}
	if m.LastModifyTimeSince != nil {
		n26, err26 := github_com_tron_us_protobuf_types.StdTimeMarshalTo(*m.LastModifyTimeSince, dAtA[i-github_com_tron_us_protobuf_types.SizeOfStdTime(*m.LastModifyTimeSince):])
		if err26 != nil {
			return 0, err26
		}
		i -= n26
		i = encodeVarintGuard(dAtA, i, uint64(n26))
		i--
		dAtA[i] = 0x2a
	}
	if m.RequestPageIndex != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.RequestPageIndex))
		i--
		dAtA[i] = 0x20
	}
	if m.RequestPageSize != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.RequestPageSize))
		i--
		dAtA[i] = 0x18
	}
	if len(m.RequesterPid) > 0 {
		i -= len(m.RequesterPid)
		copy(dAtA[i:], m.RequesterPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.RequesterPid)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.HostPid) > 0 {
		i -= len(m.HostPid)
		copy(dAtA[i:], m.HostPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.HostPid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ContractsList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContractsList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContractsList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Count != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Contracts) > 0 {
		for iNdEx := len(m.Contracts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Contracts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGuard(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	n27, err27 := github_com_tron_us_protobuf_types.StdTimeMarshalTo(m.GenerateTime, dAtA[i-github_com_tron_us_protobuf_types.SizeOfStdTime(m.GenerateTime):])
	if err27 != nil {
		return 0, err27
	}
	i -= n27
	i = encodeVarintGuard(dAtA, i, uint64(n27))
	i--
	dAtA[i] = 0x12
	if m.Request != nil {
		{
			size, err := m.Request.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGuard(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReadyForChallengeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadyForChallengeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadyForChallengeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsRepair {
		i--
		if m.IsRepair {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x3a
	}
	n29, err29 := github_com_tron_us_protobuf_types.StdTimeMarshalTo(m.PrepareTime, dAtA[i-github_com_tron_us_protobuf_types.SizeOfStdTime(m.PrepareTime):])
	if err29 != nil {
		return 0, err29
	}
	i -= n29
	i = encodeVarintGuard(dAtA, i, uint64(n29))
	i--
	dAtA[i] = 0x32
	if len(m.HostPid) > 0 {
		i -= len(m.HostPid)
		copy(dAtA[i:], m.HostPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.HostPid)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ShardHash) > 0 {
		i -= len(m.ShardHash)
		copy(dAtA[i:], m.ShardHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.ShardHash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.FileHash) > 0 {
		i -= len(m.FileHash)
		copy(dAtA[i:], m.FileHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.FileHash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RenterPid) > 0 {
		i -= len(m.RenterPid)
		copy(dAtA[i:], m.RenterPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.RenterPid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RequestChallengeQuestion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestChallengeQuestion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestChallengeQuestion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FileHash) > 0 {
		i -= len(m.FileHash)
		copy(dAtA[i:], m.FileHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.FileHash)))
		i--
		dAtA[i] = 0x2a
	}
	if m.IsRepair {
		i--
		if m.IsRepair {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x1a
	}
	n30, err30 := github_com_tron_us_protobuf_types.StdTimeMarshalTo(m.PrepareTime, dAtA[i-github_com_tron_us_protobuf_types.SizeOfStdTime(m.PrepareTime):])
	if err30 != nil {
		return 0, err30
	}
	i -= n30
	i = encodeVarintGuard(dAtA, i, uint64(n30))
	i--
	dAtA[i] = 0x12
	if m.Question != nil {
		{
			size, err := m.Question.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGuard(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResponseChallengeQuestion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseChallengeQuestion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseChallengeQuestion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FileHash) > 0 {
		i -= len(m.FileHash)
		copy(dAtA[i:], m.FileHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.FileHash)))
		i--
		dAtA[i] = 0x32
	}
	if m.IsRepair {
		i--
		if m.IsRepair {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x22
	}
	n32, err32 := github_com_tron_us_protobuf_types.StdTimeMarshalTo(m.ResolveTime, dAtA[i-github_com_tron_us_protobuf_types.SizeOfStdTime(m.ResolveTime):])
	if err32 != nil {
		return 0, err32
	}
	i -= n32
	i = encodeVarintGuard(dAtA, i, uint64(n32))
	i--
	dAtA[i] = 0x1a
	if len(m.HostPid) > 0 {
		i -= len(m.HostPid)
		copy(dAtA[i:], m.HostPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.HostPid)))
		i--
		dAtA[i] = 0x12
	}
	if m.Answer != nil {
		{
			size, err := m.Answer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGuard(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ForceRepairRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ForceRepairRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ForceRepairRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AuthPid) > 0 {
		i -= len(m.AuthPid)
		copy(dAtA[i:], m.AuthPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.AuthPid)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.FileHash) > 0 {
		i -= len(m.FileHash)
		copy(dAtA[i:], m.FileHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.FileHash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RenterPid) > 0 {
		i -= len(m.RenterPid)
		copy(dAtA[i:], m.RenterPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.RenterPid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Result) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Result) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Result) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	n34, err34 := github_com_tron_us_protobuf_types.StdTimeMarshalTo(m.ResponseTime, dAtA[i-github_com_tron_us_protobuf_types.SizeOfStdTime(m.ResponseTime):])
	if err34 != nil {
		return 0, err34
	}
	i -= n34
	i = encodeVarintGuard(dAtA, i, uint64(n34))
	i--
	dAtA[i] = 0x1a
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RepairContract) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RepairContract) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RepairContract) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.GuardSignature) > 0 {
		i -= len(m.GuardSignature)
		copy(dAtA[i:], m.GuardSignature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.GuardSignature)))
		i--
		dAtA[i] = 0x62
	}
	n35, err35 := github_com_tron_us_protobuf_types.StdTimeMarshalTo(m.GuardSignTime, dAtA[i-github_com_tron_us_protobuf_types.SizeOfStdTime(m.GuardSignTime):])
	if err35 != nil {
		return 0, err35
	}
	i -= n35
	i = encodeVarintGuard(dAtA, i, uint64(n35))
	i--
	dAtA[i] = 0x5a
	if len(m.RepairContractId) > 0 {
		i -= len(m.RepairContractId)
		copy(dAtA[i:], m.RepairContractId)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.RepairContractId)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.DownloadContractId) > 0 {
		i -= len(m.DownloadContractId)
		copy(dAtA[i:], m.DownloadContractId)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.DownloadContractId)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.RepairSignature) > 0 {
		i -= len(m.RepairSignature)
		copy(dAtA[i:], m.RepairSignature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.RepairSignature)))
		i--
		dAtA[i] = 0x42
	}
	n36, err36 := github_com_tron_us_protobuf_types.StdTimeMarshalTo(m.RepairSignTime, dAtA[i-github_com_tron_us_protobuf_types.SizeOfStdTime(m.RepairSignTime):])
	if err36 != nil {
		return 0, err36
	}
	i -= n36
	i = encodeVarintGuard(dAtA, i, uint64(n36))
	i--
	dAtA[i] = 0x3a
	if len(m.RepairPid) > 0 {
		i -= len(m.RepairPid)
		copy(dAtA[i:], m.RepairPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.RepairPid)))
		i--
		dAtA[i] = 0x32
	}
	if m.RepairRewardAmount != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.RepairRewardAmount))
		i--
		dAtA[i] = 0x28
	}
	if m.DownloadRewardAmount != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.DownloadRewardAmount))
		i--
		dAtA[i] = 0x20
	}
	if m.FileSize != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.FileSize))
		i--
		dAtA[i] = 0x18
	}
	if len(m.LostShardHash) > 0 {
		for iNdEx := len(m.LostShardHash) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.LostShardHash[iNdEx])
			copy(dAtA[i:], m.LostShardHash[iNdEx])
			i = encodeVarintGuard(dAtA, i, uint64(len(m.LostShardHash[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.FileHash) > 0 {
		i -= len(m.FileHash)
		copy(dAtA[i:], m.FileHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.FileHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RepairContractResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RepairContractResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RepairContractResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.Contract != nil {
		{
			size, err := m.Contract.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGuard(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RequestRepairContracts) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestRepairContracts) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestRepairContracts) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RepairSignature) > 0 {
		i -= len(m.RepairSignature)
		copy(dAtA[i:], m.RepairSignature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.RepairSignature)))
		i--
		dAtA[i] = 0x22
	}
	n38, err38 := github_com_tron_us_protobuf_types.StdTimeMarshalTo(m.RepairSignTime, dAtA[i-github_com_tron_us_protobuf_types.SizeOfStdTime(m.RepairSignTime):])
	if err38 != nil {
		return 0, err38
	}
	i -= n38
	i = encodeVarintGuard(dAtA, i, uint64(n38))
	i--
	dAtA[i] = 0x1a
	if len(m.RepairNode) > 0 {
		i -= len(m.RepairNode)
		copy(dAtA[i:], m.RepairNode)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.RepairNode)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FileHash) > 0 {
		i -= len(m.FileHash)
		copy(dAtA[i:], m.FileHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.FileHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResponseRepairContracts) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseRepairContracts) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseRepairContracts) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.GuardSignature) > 0 {
		i -= len(m.GuardSignature)
		copy(dAtA[i:], m.GuardSignature)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.GuardSignature)))
		i--
		dAtA[i] = 0x3a
	}
	n39, err39 := github_com_tron_us_protobuf_types.StdTimeMarshalTo(m.SignTime, dAtA[i-github_com_tron_us_protobuf_types.SizeOfStdTime(m.SignTime):])
	if err39 != nil {
		return 0, err39
	}
	i -= n39
	i = encodeVarintGuard(dAtA, i, uint64(n39))
	i--
	dAtA[i] = 0x32
	if len(m.GuardPid) > 0 {
		i -= len(m.GuardPid)
		copy(dAtA[i:], m.GuardPid)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.GuardPid)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGuard(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.State != 0 {
		i = encodeVarintGuard(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x18
	}
	if len(m.RepairNode) > 0 {
		i -= len(m.RepairNode)
		copy(dAtA[i:], m.RepairNode)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.RepairNode)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FileHash) > 0 {
		i -= len(m.FileHash)
		copy(dAtA[i:], m.FileHash)
		i = encodeVarintGuard(dAtA, i, uint64(len(m.FileHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintGuard(dAtA []byte, offset int, v uint64) int {
	offset -= sovGuard(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func NewPopulatedLog(r randyGuard, easy bool) *Log {
	this := &Log{}
	v1 := github_com_tron_us_protobuf_types.NewPopulatedStdTime(r, easy)
	this.ChangeTime = *v1
	this.OriginatorPid = string(randStringGuard(r))
	this.Change = string(randStringGuard(r))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 4)
	}
	return this
}

func NewPopulatedContractMeta(r randyGuard, easy bool) *ContractMeta {
	this := &ContractMeta{}
	this.ContractId = string(randStringGuard(r))
	this.RenterPid = string(randStringGuard(r))
	this.HostPid = string(randStringGuard(r))
	this.ShardHash = string(randStringGuard(r))
	this.ShardIndex = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.ShardIndex *= -1
	}
	this.ShardFileSize = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.ShardFileSize *= -1
	}
	this.FileHash = string(randStringGuard(r))
	v2 := github_com_tron_us_protobuf_types.NewPopulatedStdTime(r, easy)
	this.RentStart = *v2
	v3 := github_com_tron_us_protobuf_types.NewPopulatedStdTime(r, easy)
	this.RentEnd = *v3
	this.GuardPid = string(randStringGuard(r))
	this.EscrowPid = string(randStringGuard(r))
	this.Price = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Price *= -1
	}
	this.Amount = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Amount *= -1
	}
	this.CollateralAmount = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.CollateralAmount *= -1
	}
	this.PayoutSchedule = ContractMeta_Schedule([]int32{0, 1, 2}[r.Intn(3)])
	this.NumPayouts = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.NumPayouts *= -1
	}
	this.ContingentAmount = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.ContingentAmount *= -1
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 18)
	}
	return this
}

func NewPopulatedContract(r randyGuard, easy bool) *Contract {
	this := &Contract{}
	v4 := NewPopulatedContractMeta(r, easy)
	this.ContractMeta = *v4
	this.State = Contract_ContractState([]int32{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}[r.Intn(13)])
	v5 := r.Intn(100)
	this.RenterSignature = make([]byte, v5)
	for i := 0; i < v5; i++ {
		this.RenterSignature[i] = byte(r.Intn(256))
	}
	v6 := r.Intn(100)
	this.HostSignature = make([]byte, v6)
	for i := 0; i < v6; i++ {
		this.HostSignature[i] = byte(r.Intn(256))
	}
	v7 := github_com_tron_us_protobuf_types.NewPopulatedStdTime(r, easy)
	this.EscrowSignedTime = *v7
	v8 := r.Intn(100)
	this.EscrowSignature = make([]byte, v8)
	for i := 0; i < v8; i++ {
		this.EscrowSignature[i] = byte(r.Intn(256))
	}
	if r.Intn(5) != 0 {
		v9 := r.Intn(5)
		this.ChangeLog = make([]*Log, v9)
		for i := 0; i < v9; i++ {
			this.ChangeLog[i] = NewPopulatedLog(r, easy)
		}
	}
	v10 := github_com_tron_us_protobuf_types.NewPopulatedStdTime(r, easy)
	this.LastModifyTime = *v10
	v11 := r.Intn(100)
	this.GuardSignature = make([]byte, v11)
	for i := 0; i < v11; i++ {
		this.GuardSignature[i] = byte(r.Intn(256))
	}
	this.PreparerPid = string(randStringGuard(r))
	v12 := r.Intn(100)
	this.PreparerSignature = make([]byte, v12)
	for i := 0; i < v12; i++ {
		this.PreparerSignature[i] = byte(r.Intn(256))
	}
	v13 := github_com_tron_us_protobuf_types.NewPopulatedStdTime(r, easy)
	this.LastSuccessChallengeTime = *v13
	v14 := github_com_tron_us_protobuf_types.NewPopulatedStdTime(r, easy)
	this.LastChallengeTime = *v14
	this.ChallengeTimes = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.ChallengeTimes *= -1
	}
	this.ChallengeWarnTimes = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.ChallengeWarnTimes *= -1
	}
	this.ChallengeSuccessTimes = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.ChallengeSuccessTimes *= -1
	}
	v15 := github_com_tron_us_protobuf_types.NewPopulatedStdTime(r, easy)
	this.FirstChallengeSuccess = *v15
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 18)
	}
	return this
}

func NewPopulatedFileStoreListResponse(r randyGuard, easy bool) *FileStoreListResponse {
	this := &FileStoreListResponse{}
	if r.Intn(5) != 0 {
		this.Request = NewPopulatedListRenterFileInfoRequest(r, easy)
	}
	v16 := github_com_tron_us_protobuf_types.NewPopulatedStdTime(r, easy)
	this.CurrentTime = *v16
	if r.Intn(5) != 0 {
		v17 := r.Intn(5)
		this.FileStoreMeta = make([]*FileStoreMeta, v17)
		for i := 0; i < v17; i++ {
			this.FileStoreMeta[i] = NewPopulatedFileStoreMeta(r, easy)
		}
	}
	this.Count = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Count *= -1
	}
	v18 := r.Intn(100)
	this.Signature = make([]byte, v18)
	for i := 0; i < v18; i++ {
		this.Signature[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 6)
	}
	return this
}

func NewPopulatedFileStoreMeta(r randyGuard, easy bool) *FileStoreMeta {
	this := &FileStoreMeta{}
	this.RenterPid = string(randStringGuard(r))
	this.FileHash = string(randStringGuard(r))
	this.FileSize = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.FileSize *= -1
	}
	v19 := github_com_tron_us_protobuf_types.NewPopulatedStdTime(r, easy)
	this.RentStart = *v19
	v20 := github_com_tron_us_protobuf_types.NewPopulatedStdTime(r, easy)
	this.RentEnd = *v20
	this.CheckFrequency = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.CheckFrequency *= -1
	}
	this.GuardFee = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.GuardFee *= -1
	}
	this.EscrowFee = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.EscrowFee *= -1
	}
	this.ShardCount = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.ShardCount *= -1
	}
	this.MinimumShards = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.MinimumShards *= -1
	}
	this.RecoverThreshold = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.RecoverThreshold *= -1
	}
	this.EscrowPid = string(randStringGuard(r))
	this.GuardPid = string(randStringGuard(r))
	this.WarnChallengeTimesLimit = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.WarnChallengeTimesLimit *= -1
	}
	this.SuccessChallengeTimesLimit = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.SuccessChallengeTimesLimit *= -1
	}
	this.CheckFrequencyWarn = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.CheckFrequencyWarn *= -1
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 17)
	}
	return this
}

func NewPopulatedFileStoreStatus(r randyGuard, easy bool) *FileStoreStatus {
	this := &FileStoreStatus{}
	v21 := NewPopulatedFileStoreMeta(r, easy)
	this.FileStoreMeta = *v21
	this.State = FileStoreStatus_MetaState([]int32{0, 1, 2, 3, 4, 5, 6, 7}[r.Intn(8)])
	if r.Intn(5) != 0 {
		v22 := r.Intn(5)
		this.Contracts = make([]*Contract, v22)
		for i := 0; i < v22; i++ {
			this.Contracts[i] = NewPopulatedContract(r, easy)
		}
	}
	v23 := r.Intn(100)
	this.RenterSignature = make([]byte, v23)
	for i := 0; i < v23; i++ {
		this.RenterSignature[i] = byte(r.Intn(256))
	}
	v24 := github_com_tron_us_protobuf_types.NewPopulatedStdTime(r, easy)
	this.GuardReceiveTime = *v24
	if r.Intn(5) != 0 {
		v25 := r.Intn(5)
		this.ChangeLog = make([]*Log, v25)
		for i := 0; i < v25; i++ {
			this.ChangeLog[i] = NewPopulatedLog(r, easy)
		}
	}
	v26 := github_com_tron_us_protobuf_types.NewPopulatedStdTime(r, easy)
	this.CurrentTime = *v26
	v27 := r.Intn(100)
	this.GuardSignature = make([]byte, v27)
	for i := 0; i < v27; i++ {
		this.GuardSignature[i] = byte(r.Intn(256))
	}
	this.RentalState = FileStoreStatus_RentalState([]int32{0, 1, 2, 3, 4}[r.Intn(5)])
	this.PreparerPid = string(randStringGuard(r))
	v28 := r.Intn(100)
	this.PreparerSignature = make([]byte, v28)
	for i := 0; i < v28; i++ {
		this.PreparerSignature[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 12)
	}
	return this
}

func NewPopulatedChallengeQuestion(r randyGuard, easy bool) *ChallengeQuestion {
	this := &ChallengeQuestion{}
	this.ShardHash = string(randStringGuard(r))
	this.HostPid = string(randStringGuard(r))
	this.ChunkIndex = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.ChunkIndex *= -1
	}
	this.Nonce = string(randStringGuard(r))
	this.ExpectAnswer = string(randStringGuard(r))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 6)
	}
	return this
}

func NewPopulatedProofOfReplicateChallenge(r randyGuard, easy bool) *ProofOfReplicateChallenge {
	this := &ProofOfReplicateChallenge{}
	v29 := NewPopulatedChallengeQuestion(r, easy)
	this.ChallengeQuestion = *v29
	v30 := github_com_tron_us_protobuf_types.NewPopulatedStdTime(r, easy)
	this.ChallengeTime = *v30
	this.GuardPid = string(randStringGuard(r))
	v31 := r.Intn(100)
	this.GuardSignature = make([]byte, v31)
	for i := 0; i < v31; i++ {
		this.GuardSignature[i] = byte(r.Intn(256))
	}
	this.HostAnswer = string(randStringGuard(r))
	v32 := github_com_tron_us_protobuf_types.NewPopulatedStdTime(r, easy)
	this.HostSignTime = *v32
	v33 := r.Intn(100)
	this.HostSignature = make([]byte, v33)
	for i := 0; i < v33; i++ {
		this.HostSignature[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 8)
	}
	return this
}

func NewPopulatedFileChallengeQuestions(r randyGuard, easy bool) *FileChallengeQuestions {
	this := &FileChallengeQuestions{}
	this.FileHash = string(randStringGuard(r))
	if r.Intn(5) != 0 {
		v34 := r.Intn(5)
		this.ShardQuestions = make([]*ShardChallengeQuestions, v34)
		for i := 0; i < v34; i++ {
			this.ShardQuestions[i] = NewPopulatedShardChallengeQuestions(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 3)
	}
	return this
}

func NewPopulatedShardChallengeQuestions(r randyGuard, easy bool) *ShardChallengeQuestions {
	this := &ShardChallengeQuestions{}
	this.FileHash = string(randStringGuard(r))
	this.ShardHash = string(randStringGuard(r))
	this.PreparerPid = string(randStringGuard(r))
	this.QuestionCount = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.QuestionCount *= -1
	}
	if r.Intn(5) != 0 {
		v35 := r.Intn(5)
		this.Questions = make([]*ChallengeQuestion, v35)
		for i := 0; i < v35; i++ {
			this.Questions[i] = NewPopulatedChallengeQuestion(r, easy)
		}
	}
	v36 := github_com_tron_us_protobuf_types.NewPopulatedStdTime(r, easy)
	this.PrepareTime = *v36
	v37 := r.Intn(100)
	this.PreparerSignature = make([]byte, v37)
	for i := 0; i < v37; i++ {
		this.PreparerSignature[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 8)
	}
	return this
}

func NewPopulatedCheckFileStoreMetaRequest(r randyGuard, easy bool) *CheckFileStoreMetaRequest {
	this := &CheckFileStoreMetaRequest{}
	this.FileHash = string(randStringGuard(r))
	this.RenterPid = string(randStringGuard(r))
	this.RequesterPid = string(randStringGuard(r))
	v38 := github_com_tron_us_protobuf_types.NewPopulatedStdTime(r, easy)
	this.RequestTime = *v38
	v39 := r.Intn(100)
	this.Signature = make([]byte, v39)
	for i := 0; i < v39; i++ {
		this.Signature[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 6)
	}
	return this
}

func NewPopulatedListRenterFileInfoRequest(r randyGuard, easy bool) *ListRenterFileInfoRequest {
	this := &ListRenterFileInfoRequest{}
	this.RenterPid = string(randStringGuard(r))
	this.RequesterPid = string(randStringGuard(r))
	this.RequestPageSize = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.RequestPageSize *= -1
	}
	this.RequestPageIndex = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.RequestPageIndex *= -1
	}
	if r.Intn(5) != 0 {
		this.RequestTime = github_com_tron_us_protobuf_types.NewPopulatedStdTime(r, easy)
	}
	if r.Intn(5) != 0 {
		this.LastModifyTime = github_com_tron_us_protobuf_types.NewPopulatedStdTime(r, easy)
	}
	v40 := r.Intn(100)
	this.Signature = make([]byte, v40)
	for i := 0; i < v40; i++ {
		this.Signature[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 8)
	}
	return this
}

func NewPopulatedListHostContractsRequest(r randyGuard, easy bool) *ListHostContractsRequest {
	this := &ListHostContractsRequest{}
	this.HostPid = string(randStringGuard(r))
	this.RequesterPid = string(randStringGuard(r))
	this.RequestPageSize = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.RequestPageSize *= -1
	}
	this.RequestPageIndex = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.RequestPageIndex *= -1
	}
	if r.Intn(5) != 0 {
		this.LastModifyTimeSince = github_com_tron_us_protobuf_types.NewPopulatedStdTime(r, easy)
	}
	if r.Intn(5) != 0 {
		this.LastModifyTimeTo = github_com_tron_us_protobuf_types.NewPopulatedStdTime(r, easy)
	}
	this.State = ListHostContractsRequest_SelectState([]int32{0, 1, 2}[r.Intn(3)])
	if r.Intn(5) != 0 {
		this.RequestTime = github_com_tron_us_protobuf_types.NewPopulatedStdTime(r, easy)
	}
	v41 := r.Intn(100)
	this.Signature = make([]byte, v41)
	for i := 0; i < v41; i++ {
		this.Signature[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 10)
	}
	return this
}

func NewPopulatedContractsList(r randyGuard, easy bool) *ContractsList {
	this := &ContractsList{}
	if r.Intn(5) != 0 {
		this.Request = NewPopulatedListHostContractsRequest(r, easy)
	}
	v42 := github_com_tron_us_protobuf_types.NewPopulatedStdTime(r, easy)
	this.GenerateTime = *v42
	if r.Intn(5) != 0 {
		v43 := r.Intn(5)
		this.Contracts = make([]*Contract, v43)
		for i := 0; i < v43; i++ {
			this.Contracts[i] = NewPopulatedContract(r, easy)
		}
	}
	this.Count = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Count *= -1
	}
	v44 := r.Intn(100)
	this.Signature = make([]byte, v44)
	for i := 0; i < v44; i++ {
		this.Signature[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 6)
	}
	return this
}

func NewPopulatedReadyForChallengeRequest(r randyGuard, easy bool) *ReadyForChallengeRequest {
	this := &ReadyForChallengeRequest{}
	this.RenterPid = string(randStringGuard(r))
	this.FileHash = string(randStringGuard(r))
	this.ShardHash = string(randStringGuard(r))
	this.ContractId = string(randStringGuard(r))
	this.HostPid = string(randStringGuard(r))
	v45 := github_com_tron_us_protobuf_types.NewPopulatedStdTime(r, easy)
	this.PrepareTime = *v45
	v46 := r.Intn(100)
	this.Signature = make([]byte, v46)
	for i := 0; i < v46; i++ {
		this.Signature[i] = byte(r.Intn(256))
	}
	this.IsRepair = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 9)
	}
	return this
}

func NewPopulatedRequestChallengeQuestion(r randyGuard, easy bool) *RequestChallengeQuestion {
	this := &RequestChallengeQuestion{}
	if r.Intn(5) != 0 {
		this.Question = NewPopulatedChallengeQuestion(r, easy)
	}
	v47 := github_com_tron_us_protobuf_types.NewPopulatedStdTime(r, easy)
	this.PrepareTime = *v47
	v48 := r.Intn(100)
	this.Signature = make([]byte, v48)
	for i := 0; i < v48; i++ {
		this.Signature[i] = byte(r.Intn(256))
	}
	this.IsRepair = bool(bool(r.Intn(2) == 0))
	this.FileHash = string(randStringGuard(r))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 6)
	}
	return this
}

func NewPopulatedResponseChallengeQuestion(r randyGuard, easy bool) *ResponseChallengeQuestion {
	this := &ResponseChallengeQuestion{}
	if r.Intn(5) != 0 {
		this.Answer = NewPopulatedChallengeQuestion(r, easy)
	}
	this.HostPid = string(randStringGuard(r))
	v49 := github_com_tron_us_protobuf_types.NewPopulatedStdTime(r, easy)
	this.ResolveTime = *v49
	v50 := r.Intn(100)
	this.Signature = make([]byte, v50)
	for i := 0; i < v50; i++ {
		this.Signature[i] = byte(r.Intn(256))
	}
	this.IsRepair = bool(bool(r.Intn(2) == 0))
	this.FileHash = string(randStringGuard(r))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 7)
	}
	return this
}

func NewPopulatedForceRepairRequest(r randyGuard, easy bool) *ForceRepairRequest {
	this := &ForceRepairRequest{}
	this.RenterPid = string(randStringGuard(r))
	this.FileHash = string(randStringGuard(r))
	this.AuthPid = string(randStringGuard(r))
	v51 := r.Intn(100)
	this.Signature = make([]byte, v51)
	for i := 0; i < v51; i++ {
		this.Signature[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 5)
	}
	return this
}

func NewPopulatedResult(r randyGuard, easy bool) *Result {
	this := &Result{}
	this.Code = ResponseCode([]int32{0, 1, 2, 20}[r.Intn(4)])
	this.Message = string(randStringGuard(r))
	v52 := github_com_tron_us_protobuf_types.NewPopulatedStdTime(r, easy)
	this.ResponseTime = *v52
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 4)
	}
	return this
}

func NewPopulatedRepairContract(r randyGuard, easy bool) *RepairContract {
	this := &RepairContract{}
	this.FileHash = string(randStringGuard(r))
	v53 := r.Intn(10)
	this.LostShardHash = make([]string, v53)
	for i := 0; i < v53; i++ {
		this.LostShardHash[i] = string(randStringGuard(r))
	}
	this.FileSize = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.FileSize *= -1
	}
	this.DownloadRewardAmount = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.DownloadRewardAmount *= -1
	}
	this.RepairRewardAmount = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.RepairRewardAmount *= -1
	}
	this.RepairPid = string(randStringGuard(r))
	v54 := github_com_tron_us_protobuf_types.NewPopulatedStdTime(r, easy)
	this.RepairSignTime = *v54
	v55 := r.Intn(100)
	this.RepairSignature = make([]byte, v55)
	for i := 0; i < v55; i++ {
		this.RepairSignature[i] = byte(r.Intn(256))
	}
	this.DownloadContractId = string(randStringGuard(r))
	this.RepairContractId = string(randStringGuard(r))
	v56 := github_com_tron_us_protobuf_types.NewPopulatedStdTime(r, easy)
	this.GuardSignTime = *v56
	v57 := r.Intn(100)
	this.GuardSignature = make([]byte, v57)
	for i := 0; i < v57; i++ {
		this.GuardSignature[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 13)
	}
	return this
}

func NewPopulatedRepairContractResponse(r randyGuard, easy bool) *RepairContractResponse {
	this := &RepairContractResponse{}
	if r.Intn(5) != 0 {
		this.Contract = NewPopulatedRepairContract(r, easy)
	}
	this.Status = RepairContractResponse_ContractResponseStatus([]int32{0, 1, 2}[r.Intn(3)])
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 3)
	}
	return this
}

func NewPopulatedRequestRepairContracts(r randyGuard, easy bool) *RequestRepairContracts {
	this := &RequestRepairContracts{}
	this.FileHash = string(randStringGuard(r))
	this.RepairNode = string(randStringGuard(r))
	v58 := github_com_tron_us_protobuf_types.NewPopulatedStdTime(r, easy)
	this.RepairSignTime = *v58
	v59 := r.Intn(100)
	this.RepairSignature = make([]byte, v59)
	for i := 0; i < v59; i++ {
		this.RepairSignature[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 5)
	}
	return this
}

func NewPopulatedResponseRepairContracts(r randyGuard, easy bool) *ResponseRepairContracts {
	this := &ResponseRepairContracts{}
	this.FileHash = string(randStringGuard(r))
	this.RepairNode = string(randStringGuard(r))
	this.State = ResponseRepairContracts_RepairStat([]int32{0, 1, 2, 3}[r.Intn(4)])
	if r.Intn(5) != 0 {
		this.Status = NewPopulatedFileStoreStatus(r, easy)
	}
	this.GuardPid = string(randStringGuard(r))
	v60 := github_com_tron_us_protobuf_types.NewPopulatedStdTime(r, easy)
	this.SignTime = *v60
	v61 := r.Intn(100)
	this.GuardSignature = make([]byte, v61)
	for i := 0; i < v61; i++ {
		this.GuardSignature[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedGuard(r, 8)
	}
	return this
}

type randyGuard interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneGuard(r randyGuard) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringGuard(r randyGuard) string {
	v62 := r.Intn(100)
	tmps := make([]rune, v62)
	for i := 0; i < v62; i++ {
		tmps[i] = randUTF8RuneGuard(r)
	}
	return string(tmps)
}
func randUnrecognizedGuard(r randyGuard, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldGuard(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldGuard(dAtA []byte, r randyGuard, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateGuard(dAtA, uint64(key))
		v63 := r.Int63()
		if r.Intn(2) == 0 {
			v63 *= -1
		}
		dAtA = encodeVarintPopulateGuard(dAtA, uint64(v63))
	case 1:
		dAtA = encodeVarintPopulateGuard(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateGuard(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateGuard(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateGuard(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateGuard(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *Log) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_tron_us_protobuf_types.SizeOfStdTime(m.ChangeTime)
	n += 1 + l + sovGuard(uint64(l))
	l = len(m.OriginatorPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.Change)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ContractMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.RenterPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.HostPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.ShardHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.ShardIndex != 0 {
		n += 1 + sovGuard(uint64(m.ShardIndex))
	}
	if m.ShardFileSize != 0 {
		n += 1 + sovGuard(uint64(m.ShardFileSize))
	}
	l = len(m.FileHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = github_com_tron_us_protobuf_types.SizeOfStdTime(m.RentStart)
	n += 1 + l + sovGuard(uint64(l))
	l = github_com_tron_us_protobuf_types.SizeOfStdTime(m.RentEnd)
	n += 1 + l + sovGuard(uint64(l))
	l = len(m.GuardPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.EscrowPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.Price != 0 {
		n += 1 + sovGuard(uint64(m.Price))
	}
	if m.Amount != 0 {
		n += 1 + sovGuard(uint64(m.Amount))
	}
	if m.CollateralAmount != 0 {
		n += 1 + sovGuard(uint64(m.CollateralAmount))
	}
	if m.PayoutSchedule != 0 {
		n += 1 + sovGuard(uint64(m.PayoutSchedule))
	}
	if m.NumPayouts != 0 {
		n += 2 + sovGuard(uint64(m.NumPayouts))
	}
	if m.ContingentAmount != 0 {
		n += 2 + sovGuard(uint64(m.ContingentAmount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Contract) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ContractMeta.Size()
	n += 1 + l + sovGuard(uint64(l))
	if m.State != 0 {
		n += 1 + sovGuard(uint64(m.State))
	}
	l = len(m.RenterSignature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.HostSignature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = github_com_tron_us_protobuf_types.SizeOfStdTime(m.EscrowSignedTime)
	n += 1 + l + sovGuard(uint64(l))
	l = len(m.EscrowSignature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if len(m.ChangeLog) > 0 {
		for _, e := range m.ChangeLog {
			l = e.Size()
			n += 1 + l + sovGuard(uint64(l))
		}
	}
	l = github_com_tron_us_protobuf_types.SizeOfStdTime(m.LastModifyTime)
	n += 1 + l + sovGuard(uint64(l))
	l = len(m.GuardSignature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.PreparerPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.PreparerSignature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = github_com_tron_us_protobuf_types.SizeOfStdTime(m.LastSuccessChallengeTime)
	n += 1 + l + sovGuard(uint64(l))
	l = github_com_tron_us_protobuf_types.SizeOfStdTime(m.LastChallengeTime)
	n += 1 + l + sovGuard(uint64(l))
	if m.ChallengeTimes != 0 {
		n += 1 + sovGuard(uint64(m.ChallengeTimes))
	}
	if m.ChallengeWarnTimes != 0 {
		n += 1 + sovGuard(uint64(m.ChallengeWarnTimes))
	}
	if m.ChallengeSuccessTimes != 0 {
		n += 2 + sovGuard(uint64(m.ChallengeSuccessTimes))
	}
	l = github_com_tron_us_protobuf_types.SizeOfStdTime(m.FirstChallengeSuccess)
	n += 2 + l + sovGuard(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FileStoreListResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Request != nil {
		l = m.Request.Size()
		n += 1 + l + sovGuard(uint64(l))
	}
	l = github_com_tron_us_protobuf_types.SizeOfStdTime(m.CurrentTime)
	n += 1 + l + sovGuard(uint64(l))
	if len(m.FileStoreMeta) > 0 {
		for _, e := range m.FileStoreMeta {
			l = e.Size()
			n += 1 + l + sovGuard(uint64(l))
		}
	}
	if m.Count != 0 {
		n += 1 + sovGuard(uint64(m.Count))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FileStoreMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RenterPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.FileHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.FileSize != 0 {
		n += 1 + sovGuard(uint64(m.FileSize))
	}
	l = github_com_tron_us_protobuf_types.SizeOfStdTime(m.RentStart)
	n += 1 + l + sovGuard(uint64(l))
	l = github_com_tron_us_protobuf_types.SizeOfStdTime(m.RentEnd)
	n += 1 + l + sovGuard(uint64(l))
	if m.CheckFrequency != 0 {
		n += 1 + sovGuard(uint64(m.CheckFrequency))
	}
	if m.GuardFee != 0 {
		n += 1 + sovGuard(uint64(m.GuardFee))
	}
	if m.EscrowFee != 0 {
		n += 1 + sovGuard(uint64(m.EscrowFee))
	}
	if m.ShardCount != 0 {
		n += 1 + sovGuard(uint64(m.ShardCount))
	}
	if m.MinimumShards != 0 {
		n += 1 + sovGuard(uint64(m.MinimumShards))
	}
	if m.RecoverThreshold != 0 {
		n += 1 + sovGuard(uint64(m.RecoverThreshold))
	}
	l = len(m.EscrowPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.GuardPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.WarnChallengeTimesLimit != 0 {
		n += 1 + sovGuard(uint64(m.WarnChallengeTimesLimit))
	}
	if m.SuccessChallengeTimesLimit != 0 {
		n += 1 + sovGuard(uint64(m.SuccessChallengeTimesLimit))
	}
	if m.CheckFrequencyWarn != 0 {
		n += 2 + sovGuard(uint64(m.CheckFrequencyWarn))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FileStoreStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.FileStoreMeta.Size()
	n += 1 + l + sovGuard(uint64(l))
	if m.State != 0 {
		n += 1 + sovGuard(uint64(m.State))
	}
	if len(m.Contracts) > 0 {
		for _, e := range m.Contracts {
			l = e.Size()
			n += 1 + l + sovGuard(uint64(l))
		}
	}
	l = len(m.RenterSignature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = github_com_tron_us_protobuf_types.SizeOfStdTime(m.GuardReceiveTime)
	n += 1 + l + sovGuard(uint64(l))
	if len(m.ChangeLog) > 0 {
		for _, e := range m.ChangeLog {
			l = e.Size()
			n += 1 + l + sovGuard(uint64(l))
		}
	}
	l = github_com_tron_us_protobuf_types.SizeOfStdTime(m.CurrentTime)
	n += 1 + l + sovGuard(uint64(l))
	l = len(m.GuardSignature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.RentalState != 0 {
		n += 1 + sovGuard(uint64(m.RentalState))
	}
	l = len(m.PreparerPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.PreparerSignature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChallengeQuestion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ShardHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.HostPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.ChunkIndex != 0 {
		n += 1 + sovGuard(uint64(m.ChunkIndex))
	}
	l = len(m.Nonce)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.ExpectAnswer)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProofOfReplicateChallenge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ChallengeQuestion.Size()
	n += 1 + l + sovGuard(uint64(l))
	l = github_com_tron_us_protobuf_types.SizeOfStdTime(m.ChallengeTime)
	n += 1 + l + sovGuard(uint64(l))
	l = len(m.GuardPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.GuardSignature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.HostAnswer)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = github_com_tron_us_protobuf_types.SizeOfStdTime(m.HostSignTime)
	n += 1 + l + sovGuard(uint64(l))
	l = len(m.HostSignature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FileChallengeQuestions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FileHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if len(m.ShardQuestions) > 0 {
		for _, e := range m.ShardQuestions {
			l = e.Size()
			n += 1 + l + sovGuard(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShardChallengeQuestions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FileHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.ShardHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.PreparerPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.QuestionCount != 0 {
		n += 1 + sovGuard(uint64(m.QuestionCount))
	}
	if len(m.Questions) > 0 {
		for _, e := range m.Questions {
			l = e.Size()
			n += 1 + l + sovGuard(uint64(l))
		}
	}
	l = github_com_tron_us_protobuf_types.SizeOfStdTime(m.PrepareTime)
	n += 1 + l + sovGuard(uint64(l))
	l = len(m.PreparerSignature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CheckFileStoreMetaRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FileHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.RenterPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.RequesterPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = github_com_tron_us_protobuf_types.SizeOfStdTime(m.RequestTime)
	n += 1 + l + sovGuard(uint64(l))
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListRenterFileInfoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RenterPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.RequesterPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.RequestPageSize != 0 {
		n += 1 + sovGuard(uint64(m.RequestPageSize))
	}
	if m.RequestPageIndex != 0 {
		n += 1 + sovGuard(uint64(m.RequestPageIndex))
	}
	if m.RequestTime != nil {
		l = github_com_tron_us_protobuf_types.SizeOfStdTime(*m.RequestTime)
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.LastModifyTime != nil {
		l = github_com_tron_us_protobuf_types.SizeOfStdTime(*m.LastModifyTime)
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListHostContractsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HostPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.RequesterPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.RequestPageSize != 0 {
		n += 1 + sovGuard(uint64(m.RequestPageSize))
	}
	if m.RequestPageIndex != 0 {
		n += 1 + sovGuard(uint64(m.RequestPageIndex))
	}
	if m.LastModifyTimeSince != nil {
		l = github_com_tron_us_protobuf_types.SizeOfStdTime(*m.LastModifyTimeSince)
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.LastModifyTimeTo != nil {
		l = github_com_tron_us_protobuf_types.SizeOfStdTime(*m.LastModifyTimeTo)
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovGuard(uint64(m.State))
	}
	if m.RequestTime != nil {
		l = github_com_tron_us_protobuf_types.SizeOfStdTime(*m.RequestTime)
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ContractsList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Request != nil {
		l = m.Request.Size()
		n += 1 + l + sovGuard(uint64(l))
	}
	l = github_com_tron_us_protobuf_types.SizeOfStdTime(m.GenerateTime)
	n += 1 + l + sovGuard(uint64(l))
	if len(m.Contracts) > 0 {
		for _, e := range m.Contracts {
			l = e.Size()
			n += 1 + l + sovGuard(uint64(l))
		}
	}
	if m.Count != 0 {
		n += 1 + sovGuard(uint64(m.Count))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReadyForChallengeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RenterPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.FileHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.ShardHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.HostPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = github_com_tron_us_protobuf_types.SizeOfStdTime(m.PrepareTime)
	n += 1 + l + sovGuard(uint64(l))
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.IsRepair {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RequestChallengeQuestion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Question != nil {
		l = m.Question.Size()
		n += 1 + l + sovGuard(uint64(l))
	}
	l = github_com_tron_us_protobuf_types.SizeOfStdTime(m.PrepareTime)
	n += 1 + l + sovGuard(uint64(l))
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.IsRepair {
		n += 2
	}
	l = len(m.FileHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResponseChallengeQuestion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Answer != nil {
		l = m.Answer.Size()
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.HostPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = github_com_tron_us_protobuf_types.SizeOfStdTime(m.ResolveTime)
	n += 1 + l + sovGuard(uint64(l))
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.IsRepair {
		n += 2
	}
	l = len(m.FileHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ForceRepairRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RenterPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.FileHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.AuthPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Result) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovGuard(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = github_com_tron_us_protobuf_types.SizeOfStdTime(m.ResponseTime)
	n += 1 + l + sovGuard(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RepairContract) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FileHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if len(m.LostShardHash) > 0 {
		for _, s := range m.LostShardHash {
			l = len(s)
			n += 1 + l + sovGuard(uint64(l))
		}
	}
	if m.FileSize != 0 {
		n += 1 + sovGuard(uint64(m.FileSize))
	}
	if m.DownloadRewardAmount != 0 {
		n += 1 + sovGuard(uint64(m.DownloadRewardAmount))
	}
	if m.RepairRewardAmount != 0 {
		n += 1 + sovGuard(uint64(m.RepairRewardAmount))
	}
	l = len(m.RepairPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = github_com_tron_us_protobuf_types.SizeOfStdTime(m.RepairSignTime)
	n += 1 + l + sovGuard(uint64(l))
	l = len(m.RepairSignature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.DownloadContractId)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.RepairContractId)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = github_com_tron_us_protobuf_types.SizeOfStdTime(m.GuardSignTime)
	n += 1 + l + sovGuard(uint64(l))
	l = len(m.GuardSignature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RepairContractResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Contract != nil {
		l = m.Contract.Size()
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovGuard(uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RequestRepairContracts) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FileHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.RepairNode)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = github_com_tron_us_protobuf_types.SizeOfStdTime(m.RepairSignTime)
	n += 1 + l + sovGuard(uint64(l))
	l = len(m.RepairSignature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResponseRepairContracts) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FileHash)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.RepairNode)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovGuard(uint64(m.State))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.GuardPid)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = github_com_tron_us_protobuf_types.SizeOfStdTime(m.SignTime)
	n += 1 + l + sovGuard(uint64(l))
	l = len(m.GuardSignature)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovGuard(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozGuard(x uint64) (n int) {
	return sovGuard(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Log) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Log: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Log: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_tron_us_protobuf_types.StdTimeUnmarshal(&m.ChangeTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginatorPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginatorPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Change", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Change = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContractMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContractMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContractMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RenterPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RenterPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShardHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardIndex", wireType)
			}
			m.ShardIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardFileSize", wireType)
			}
			m.ShardFileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardFileSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RentStart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_tron_us_protobuf_types.StdTimeUnmarshal(&m.RentStart, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RentEnd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_tron_us_protobuf_types.StdTimeUnmarshal(&m.RentEnd, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuardPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuardPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EscrowPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EscrowPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			m.Price = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Price |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollateralAmount", wireType)
			}
			m.CollateralAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CollateralAmount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayoutSchedule", wireType)
			}
			m.PayoutSchedule = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PayoutSchedule |= ContractMeta_Schedule(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumPayouts", wireType)
			}
			m.NumPayouts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumPayouts |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContingentAmount", wireType)
			}
			m.ContingentAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContingentAmount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Contract) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Contract: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Contract: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ContractMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= Contract_ContractState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RenterSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RenterSignature = append(m.RenterSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.RenterSignature == nil {
				m.RenterSignature = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostSignature = append(m.HostSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.HostSignature == nil {
				m.HostSignature = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EscrowSignedTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_tron_us_protobuf_types.StdTimeUnmarshal(&m.EscrowSignedTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EscrowSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EscrowSignature = append(m.EscrowSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.EscrowSignature == nil {
				m.EscrowSignature = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeLog", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChangeLog = append(m.ChangeLog, &Log{})
			if err := m.ChangeLog[len(m.ChangeLog)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastModifyTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_tron_us_protobuf_types.StdTimeUnmarshal(&m.LastModifyTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuardSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuardSignature = append(m.GuardSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.GuardSignature == nil {
				m.GuardSignature = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreparerPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreparerPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreparerSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreparerSignature = append(m.PreparerSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.PreparerSignature == nil {
				m.PreparerSignature = []byte{}
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSuccessChallengeTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_tron_us_protobuf_types.StdTimeUnmarshal(&m.LastSuccessChallengeTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastChallengeTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_tron_us_protobuf_types.StdTimeUnmarshal(&m.LastChallengeTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeTimes", wireType)
			}
			m.ChallengeTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChallengeTimes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeWarnTimes", wireType)
			}
			m.ChallengeWarnTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChallengeWarnTimes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeSuccessTimes", wireType)
			}
			m.ChallengeSuccessTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChallengeSuccessTimes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstChallengeSuccess", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_tron_us_protobuf_types.StdTimeUnmarshal(&m.FirstChallengeSuccess, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileStoreListResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileStoreListResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileStoreListResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Request == nil {
				m.Request = &ListRenterFileInfoRequest{}
			}
			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_tron_us_protobuf_types.StdTimeUnmarshal(&m.CurrentTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileStoreMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileStoreMeta = append(m.FileStoreMeta, &FileStoreMeta{})
			if err := m.FileStoreMeta[len(m.FileStoreMeta)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileStoreMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileStoreMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileStoreMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RenterPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RenterPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RentStart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_tron_us_protobuf_types.StdTimeUnmarshal(&m.RentStart, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RentEnd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_tron_us_protobuf_types.StdTimeUnmarshal(&m.RentEnd, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckFrequency", wireType)
			}
			m.CheckFrequency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CheckFrequency |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuardFee", wireType)
			}
			m.GuardFee = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuardFee |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EscrowFee", wireType)
			}
			m.EscrowFee = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EscrowFee |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardCount", wireType)
			}
			m.ShardCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinimumShards", wireType)
			}
			m.MinimumShards = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinimumShards |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecoverThreshold", wireType)
			}
			m.RecoverThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecoverThreshold |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EscrowPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EscrowPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuardPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuardPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WarnChallengeTimesLimit", wireType)
			}
			m.WarnChallengeTimesLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WarnChallengeTimesLimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuccessChallengeTimesLimit", wireType)
			}
			m.SuccessChallengeTimesLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SuccessChallengeTimesLimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckFrequencyWarn", wireType)
			}
			m.CheckFrequencyWarn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CheckFrequencyWarn |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileStoreStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileStoreStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileStoreStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileStoreMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FileStoreMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= FileStoreStatus_MetaState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contracts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Contracts = append(m.Contracts, &Contract{})
			if err := m.Contracts[len(m.Contracts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RenterSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RenterSignature = append(m.RenterSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.RenterSignature == nil {
				m.RenterSignature = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuardReceiveTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_tron_us_protobuf_types.StdTimeUnmarshal(&m.GuardReceiveTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeLog", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChangeLog = append(m.ChangeLog, &Log{})
			if err := m.ChangeLog[len(m.ChangeLog)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_tron_us_protobuf_types.StdTimeUnmarshal(&m.CurrentTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuardSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuardSignature = append(m.GuardSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.GuardSignature == nil {
				m.GuardSignature = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RentalState", wireType)
			}
			m.RentalState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RentalState |= FileStoreStatus_RentalState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreparerPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreparerPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreparerSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreparerSignature = append(m.PreparerSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.PreparerSignature == nil {
				m.PreparerSignature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChallengeQuestion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChallengeQuestion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChallengeQuestion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShardHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkIndex", wireType)
			}
			m.ChunkIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChunkIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectAnswer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExpectAnswer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProofOfReplicateChallenge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProofOfReplicateChallenge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProofOfReplicateChallenge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeQuestion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ChallengeQuestion.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_tron_us_protobuf_types.StdTimeUnmarshal(&m.ChallengeTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuardPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuardPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuardSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuardSignature = append(m.GuardSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.GuardSignature == nil {
				m.GuardSignature = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostAnswer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostAnswer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostSignTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_tron_us_protobuf_types.StdTimeUnmarshal(&m.HostSignTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostSignature = append(m.HostSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.HostSignature == nil {
				m.HostSignature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileChallengeQuestions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileChallengeQuestions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileChallengeQuestions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardQuestions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShardQuestions = append(m.ShardQuestions, &ShardChallengeQuestions{})
			if err := m.ShardQuestions[len(m.ShardQuestions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardChallengeQuestions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardChallengeQuestions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardChallengeQuestions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShardHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreparerPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreparerPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuestionCount", wireType)
			}
			m.QuestionCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QuestionCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Questions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Questions = append(m.Questions, &ChallengeQuestion{})
			if err := m.Questions[len(m.Questions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrepareTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_tron_us_protobuf_types.StdTimeUnmarshal(&m.PrepareTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreparerSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreparerSignature = append(m.PreparerSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.PreparerSignature == nil {
				m.PreparerSignature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckFileStoreMetaRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckFileStoreMetaRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckFileStoreMetaRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RenterPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RenterPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequesterPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequesterPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_tron_us_protobuf_types.StdTimeUnmarshal(&m.RequestTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListRenterFileInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListRenterFileInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListRenterFileInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RenterPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RenterPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequesterPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequesterPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestPageSize", wireType)
			}
			m.RequestPageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestPageSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestPageIndex", wireType)
			}
			m.RequestPageIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestPageIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RequestTime == nil {
				m.RequestTime = new(time.Time)
			}
			if err := github_com_tron_us_protobuf_types.StdTimeUnmarshal(m.RequestTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastModifyTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastModifyTime == nil {
				m.LastModifyTime = new(time.Time)
			}
			if err := github_com_tron_us_protobuf_types.StdTimeUnmarshal(m.LastModifyTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListHostContractsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListHostContractsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListHostContractsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequesterPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequesterPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestPageSize", wireType)
			}
			m.RequestPageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestPageSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestPageIndex", wireType)
			}
			m.RequestPageIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestPageIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastModifyTimeSince", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastModifyTimeSince == nil {
				m.LastModifyTimeSince = new(time.Time)
			}
			if err := github_com_tron_us_protobuf_types.StdTimeUnmarshal(m.LastModifyTimeSince, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastModifyTimeTo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastModifyTimeTo == nil {
				m.LastModifyTimeTo = new(time.Time)
			}
			if err := github_com_tron_us_protobuf_types.StdTimeUnmarshal(m.LastModifyTimeTo, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= ListHostContractsRequest_SelectState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RequestTime == nil {
				m.RequestTime = new(time.Time)
			}
			if err := github_com_tron_us_protobuf_types.StdTimeUnmarshal(m.RequestTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContractsList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContractsList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContractsList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Request == nil {
				m.Request = &ListHostContractsRequest{}
			}
			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenerateTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_tron_us_protobuf_types.StdTimeUnmarshal(&m.GenerateTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contracts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Contracts = append(m.Contracts, &Contract{})
			if err := m.Contracts[len(m.Contracts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadyForChallengeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadyForChallengeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadyForChallengeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RenterPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RenterPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShardHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrepareTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_tron_us_protobuf_types.StdTimeUnmarshal(&m.PrepareTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRepair", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRepair = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestChallengeQuestion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestChallengeQuestion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestChallengeQuestion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Question", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Question == nil {
				m.Question = &ChallengeQuestion{}
			}
			if err := m.Question.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrepareTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_tron_us_protobuf_types.StdTimeUnmarshal(&m.PrepareTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRepair", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRepair = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseChallengeQuestion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseChallengeQuestion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseChallengeQuestion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Answer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Answer == nil {
				m.Answer = &ChallengeQuestion{}
			}
			if err := m.Answer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolveTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_tron_us_protobuf_types.StdTimeUnmarshal(&m.ResolveTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRepair", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRepair = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ForceRepairRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForceRepairRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForceRepairRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RenterPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RenterPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Result) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Result: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Result: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= ResponseCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_tron_us_protobuf_types.StdTimeUnmarshal(&m.ResponseTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepairContract) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepairContract: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepairContract: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LostShardHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LostShardHash = append(m.LostShardHash, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownloadRewardAmount", wireType)
			}
			m.DownloadRewardAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DownloadRewardAmount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepairRewardAmount", wireType)
			}
			m.RepairRewardAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RepairRewardAmount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepairPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepairPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepairSignTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_tron_us_protobuf_types.StdTimeUnmarshal(&m.RepairSignTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepairSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepairSignature = append(m.RepairSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.RepairSignature == nil {
				m.RepairSignature = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownloadContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DownloadContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepairContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepairContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuardSignTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_tron_us_protobuf_types.StdTimeUnmarshal(&m.GuardSignTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuardSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuardSignature = append(m.GuardSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.GuardSignature == nil {
				m.GuardSignature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepairContractResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepairContractResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepairContractResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contract", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Contract == nil {
				m.Contract = &RepairContract{}
			}
			if err := m.Contract.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= RepairContractResponse_ContractResponseStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestRepairContracts) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestRepairContracts: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestRepairContracts: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepairNode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepairNode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepairSignTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_tron_us_protobuf_types.StdTimeUnmarshal(&m.RepairSignTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepairSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepairSignature = append(m.RepairSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.RepairSignature == nil {
				m.RepairSignature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseRepairContracts) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseRepairContracts: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseRepairContracts: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepairNode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepairNode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= ResponseRepairContracts_RepairStat(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &FileStoreStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuardPid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuardPid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_tron_us_protobuf_types.StdTimeUnmarshal(&m.SignTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuardSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGuard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuardSignature = append(m.GuardSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.GuardSignature == nil {
				m.GuardSignature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGuard(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthGuard
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupGuard
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthGuard
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthGuard        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGuard          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupGuard = fmt.Errorf("proto: unexpected end of group")
)
