syntax = "proto3";



package btfs;


service guard {

  	rpc startContract (Contract) returns (Contract) {} //used for renter submit the contract
  	rpc checkContract(CheckContractRequest) returns (ContractStatus){} //reserved for other nodes to check contract status
  	rpc reportUploadStatus(UploadStatusReport) returns(Result){} //used for renter submit upload status
  	rpc updatePayment(PaymentStatus) returns (Result){}  //reserved, notification while payment has been changed from escrow
  	rpc health() returns(HealthStatus){} //used for other nodes check guard health , TBD input argument
  	
}

//service provided by escrow need to be request by guard
service escrow{
	rpc reserveFund(ProofOfFund) returns (ProofOfFund){}
	rpc startEscrow(StartEscrowRequest) returns (PaymentStatus){}
	rpc changeEscrow(changeEscrowRequest) returns(PaymentStatus){}
}

//host provided service
service host{
	rpc challenge(ProofOfReplicateChallenge) returns (ProofOfReplicateChallenge){} //used for receieve challenge question and return the answer
}

service renter{
	rpc requestQuestions(ChanllengeQuestionsRequest) returns(Questions){} //used for guard request challenge questions 
}



message ProofOfFund{
	int64 id = 1;// the proof id provide by escrow
	bytes reference_id = 2; //the reference id to present purpose of such proof, in the BTFS, it is file_hash or shard_hash
	bytes escrow_address = 3; //the escrow service’s public key 
	bytes owner_address = 4; //owner’s public key
	bytes target_address = 5; //payment target’s pub key, in BTFS, it is host pub key for renter prepare such POF, and is renter pub key for host to prepare such POF
	bytes manager_address = 6; //the manager’s(guard) public key, which can decide to transfer money out
	enum TokenType{
		BTT = 0; 
    }
	TokenType token_type = 7; // token type enum
	int64 amount = 8; //the amount of this proof 
	Timestamp signed_time = 9; //escrow signed_time 
	Timestamp expire_time = 10; //the expire time of such proof 
	bytes owner_signature = 11; //owner's signature for the money 
	bytes escrow_signature = 12; //escrow’s signature
}

message SubContract{
	bytes renter_address = 1; //renter's wallet address
	bytes host_address =2; //host’s wallet address
	bytes shard_hash = 3; //shard’s hash
	int shard_index = 4; //shard’s sequence of the original file
	int64 shard_file_size = 5; //shard’s file size
	int64 proposed_price = 6; //renter proposed price 
	Timestamp rent_start = 7; //rent start time
	Timestamp rent_end = 8 ; //rent end time
	bytes guard_address = 9; //renter proposed guard's address
	bytes escrow_address = 10; //renter proposed escrow's address
	bytes renter_propose_signature = 11; //renter signature for proposed information, signed for above information
	int64 agreed_price = 12; //the price which agreed by host and rental, on the first phase, it equal to the proposed_price
	int64 agreed_amount = 13; //the amount which agreed by host and rental, on the first phase, it should be equal file_size*duration*agreed_price
	int pay_frequency = 14; //payment frequency of such shard , TBD need escrow suggestion
	bytes host_agreed_signature = 15; //renter signature for proposed information, signed for above information
	ProofOfFund renter_pre_qualify = 16; // the proof of renter had reserve money in the escrow for such shard 
	ProofOfFund host_pre_qualify = 17; //the proof of host for collateral
	Timestamp signed_time = 18; //contract signed time
	Timestamp expire_time = 19; // the time when the agreement got expired, which should be equal with expire time in the Proof of fund
	bytes renter_signature = 20; //renter’s signature for the sub contract
	bytes host_signature = 21; //host’s signature from the sub contract
}


message Contract{
	bytes renter_address = 1; // buyer wallet address
	bytes file_hash = 2; // file’s hash
	int64 file_size = 3; // file’s size
	Timestamp rent_start = 4; //rent start time
	Timestamp rent_end = 5; //rent end time
	int check_frequence = 6; // shard check frequence in a year,  1 means check once per year
	int64 guard_fee= 7; // reserve: the fee which guard will charge for supporting 
	int64 escrow_fee = 8; //reserve: the fee which escrow will charge for supporting
	ProofOfFund management_fee = 9; //reserve: the fee which will be pay to guard and escrow
	int shard_count = 10; //shard's count
	int recover_threshold = 11; //reserved field, indicate the right shard count for the file
	repeated SubContract SubContracts = 12;
	bytes escrow_address = 13;
	bytes guard_address = 14;
	bytes renter_signature = 15; //renter's signature for above information
	bytes contract_id = 16; //id of the contract provided by guard
	Timestamp sign_time = 17; //guard signed time, which is contract start time
	bytes guard_signature = 18; //guard's signature for above information
}

message ChanllengeQuestion{
	bytes shard_hash = 1 //shard hash 
	bytes host_address = 2 //host's address
	int chunk_index = 3 //the chunk's index for calculation
	int random_nounce = 4 //the challenge questions's random nounce 
	bytes expect_answer = 5 //the challenge expected answer, 
}

message ProofOfReplicateChallenge{
	ChanllengeQuestion question = 1; //of course expect_answer should be clear before send to the host`
	Timestamp challenge_time = 2 //challenge time from guard
	bytes guard_address = 3 //guar's address
	bytes guard_signature = 4 //guard signed for the challenge
	bytes host_answer = 5 //challenge answer
	Timestamp host_sign_time = 6 //response time from host
	bytes host_signature = 7
}

message ChanllengeQuestionsRequest{
	bytes file_hash = 1;
	bytes shard_hash = 2;
	bytes guard_address = 3;
	int request_count = 4;
	Timestamp request_time = 5;
	bytes guard_signature = 6;
}

message ChallengeQuestions{
	bytes file_hash = 1; //file's hash
	bytes shard_hash = 2;
	bytes preparer_address = 3 ; //challenge questions preparer's address, it is renter address at phase 1
	int request_count = 4;
	repeated ChanllengeQuestion = 5;
	Timestamp prepare_time = 6;
	bytes renter_signature = 7;
}

message SubContractStatus{
	bytes renter_address = 1; //renter's wallet address
	bytes host_address =2; //host’s wallet address
	bytes shard_hash = 3; //shard’s hash
	int shard_index = 4; //shard’s sequence of the original file
	int64 shard_file_size = 5; //shard’s file size
	bytes payment_id = 6; //escrow assigned id for the payment
	int64 total_amount = 7; //whole amount of the subcontract , equal rent amount + collateral amount
	int64 withhold_amount = 8;
	int64 collateral_amount = 9;
	int64 paid_amount = 10;
	int64 next_payment_amount = 11;
	Timestamp rent_start = 12; //rent start time
	Timestamp rent_end = 13 ; //rent end time
	Timestamp file_uploaded_time = 14; // the time when the file upload was done
	ProofOfReplicateChallenge last_challenge = 15; // the last challenge  
	Timestamp last_payment_time = 16; 
	Timestamp next_payment_amount = 17;
	enum State{
		INIT = 0; //the contract was init, but the first challenge is not done. Which means host is reserve the space, but the renter had not used it for whole shard.  
    	RUNNING = 1; //the renter is using the host's space for the shard. 
    	CHANGING_HOST = 2;  //Guard is working to change the host
    	CLOSED = 3; //the sub contract was closed, no payment occur in the future. 
    	CANCELED = 4; //reserve state, for some situation that the subcontract was closed abnormally
	}
	State state = 18;
	bytes escrow_signature = 19; //signature got from escrow while last payment status check
	Timestamp status_time = 20;  //current status generated time
	bytes guard_signature = 21; //guard signature for previous information
}

message ContractStatus{
	bytes renter_address = 1; // buyer wallet address
	bytes guard_address =2; //guard wallet address
	bytes escrow_address = 3; //escrow wallet address
	bytes file_hash = 4; //file's hash 
	int64 file_size = 5; //file's size
	Timestamp rent_start = 6;
	Timestamp rent_end = 7;
	int shard_count = 8; //shard's count
	int recover_threshold = 9; //reserved field, indicate the right shard count for the file
	int check_frequence = 10; //check's frequency, 1 means check once per year
	repeated SubContractStatus SubContractStatus = 11; //all sub contract's status
	Timestamp status_time = 12;  //current status generated time
	bytes previous_status_id = 13; //previous contract status id, if it is first, mark it as 0
	bytes status_id = 14; //the hash of the current status
	bytes signature = 15; //guard's signature of such status
}

message UploadStatusReport{
	bytes renter_address = 1; 
	bytes host_address = 2;
	bytes shard_hash = 3;
	int64 shard_size = 4;
	int64 upload_size = 5;
	int64 bandwidth_since_last_report = 6; //bps since last bandwidth_since_last_report
	int64 connection_lost_times = 7;
	Timestamp report_time = 8;
	bytes signature = 9; //renter's signature of the report
}

message CheckContractRequest{
	bytes file_hash = 1;
	bytes renter_address = 2;
	bytes requester_address = 3;
	bytes signature =4; //requester signed 
}

message StartEscrowRequest{
	ProofOfFund escrow_amount = 1; // the proof of renter had reserve money in the escrow for such shard 
	ProofOfFund escrow_collateral_amount = 2; //the proof of host for collateral
	enum TokenType{
		BTT = 0; 
    }
	TokenType token_type = 3; // token type enum
	enum Schedule{
		IMME = 0; // immediate
    	DAY = 1;
    	WEEK = 2;
    	MONTH = 3;
	}
    Schedule payout_schedule = 4; // schedule enum
   	int32 num_payouts = 5; // numbers of payouts
	bytes peerId = 6; //reserve: guard's instance's peerId
	bytes signature = 7; 
}

message changeEscrowRequest{
	bytes escrow_id =1;
	bytes admin_address =2;
	enum RequestType{
		NOCHANGE = 0;
		STARTPAY = 1;
		PAYSINCENOW = 2;
		FREEZE = 3; //reserved
		STOP = 4;
	}
	RequestType RequestType = 3;
	Timestamp request_sign_time = 4;
	bytes signature = 5; 
}

// message StopEscrowRequest{
// 	bytes escrow_id =1;
// 	bytes admin_address =2;
// 	Timestamp stop_sign_time = 3;
// 	bytes signature = 4; 
// }

message PaymentStatus{ 
	//fields need by guard for escrow payment's staus, need ESCROW decision and revise
	bytes from_address = 1; //the fund's original address, in BTFS it should be renter_address
	bytes to_address = 2; //the fund's target wallet address, in BTFS it should be host's address
	bytes manager_address = 3; //the manager's wallet address, in BTFS it should be guard's address
	enum status{
		NOTSTART = 0;
		RUNNING = 1;
		PAUSE = 2;
		DONE = 3;
	}
	status status = 4;
	bytes escrow_id = 5; //escrow assigned id for the payment
	int64 total_amount = 6; //whole amount of the subcontract , equal rent amount + collateral amount
	int64 collateral_amount = 7;
	int64 withhold_amount = 8;
	int64 paid_amount = 9;
	int64 next_payment_amount = 10;
	Timestamp next_payment_time = 11;
	Timestamp last_payment_time = 12;
	Timestamp status_time = 13;
	bytes signature = 14;
}


message Result {
    enum response_code {
      SUCCESS = 0;
      SIGNATURE_FORMAT_ERROR = 1;
      COMPUTE_ADDRESS_ERROR = 2;
      OTHER_ERROR = 20;
    }
    response_code code = 1;
    string message = 2;
}

message HealthStatus{
	bytes peerID =1 //guard’s peer ID
	bytes guard_address = 2 //guard’s pub key/address
	enum status{
		WRONG = 0;
		RUNNING = 1;
		BOOTSTRAP = 2; //reserve 
		PARTIAL_STOP = 3; //reserve field, some function cannot work
	}
	status Status = 3 //current status , running, starting, partial stop
	Timestamp now =4 //current time of guard
	Bytes Signature =5 //signature

}