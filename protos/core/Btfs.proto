syntax = "proto3";



package btfs;





// service EscrowService{. //FYI from Cong's review, this part will be removed eventually
// 	submitContracts()
// 	fullPay()
// 	checkContract()
// 	cancelContract()
// }

service GuardService{
	rpc submitFileStoreMeta(FileStoreMeta) returns (Result){}
	rpc health() returns(HealthStatus){} //used for other nodes check guard health , TBD input argument
  	rpc sendQuestions(Questions) returns(Result){} //used for renter send the questions to guard
  	rpc checkFileStoreMeta(CheckFileStoreMetaRequest) returns (FileStoreMeta){} //reserved for other nodes to check contract status
}

service HostService{
	rpc challenge(ProofOfReplicateChallenge) returns (ProofOfReplicateChallenge){} //used for receieve challenge question and return the answer, TBD seems can be removed as the BTFS has embed function
	rpc cancelContract(Contract) returns (Result){} 
}

//the relationship of the objects from Guard's view
// FileStoreMeta (1:n) Contract (1:n) payout






//contract is the signed document between the renter and host for one shard's storage
// the contract information contains buyer, seller, escrow, guard , storage shard's information, rent duration, amount, payment method(periodically and times)
message Contract{
	bytes contract_id = 1; //one id which generated by renter, and will be check unique by escrow service
	bytes renter_address = 2; //renter's wallet address
	bytes host_address = 3; //host’s wallet address
	bytes shard_hash = 4; //shard’s hash
	int shard_index = 5; //shard’s sequence of the original file
	int64 shard_file_size = 6; //shard’s file size
	bytes file_hash = 7; //original file's hash, reserved point back to FileStoreMeta
	Timestamp rent_start = 7; //rent start time
	Timestamp rent_end = 8 ; //rent end time
	bytes guard_address = 9; //renter proposed guard's address
	bytes escrow_address = 10; //renter proposed escrow's address
	bytes renter_propose_signature = 11; //renter signature for proposed information, signed for above information
	int64 agreed_price = 12; //the price which agreed by host and rental, on the first phase, it equal to the proposed_price
	int64 agreed_amount = 13; //the amount which agreed by host and rental, on the first phase, it should be equal file_size*duration*agreed_price
	int64 agreed_collaeteral_amount = 14; 
	enum Schedule{		
    	MONTHLY = 0;
    	QUARTERLY = 1;
    	ANNUALLY = 2;
	}
    Schedule payout_schedule = 15; // schedule for payouts
   	int32 num_payouts = 16; // numbers of payouts
	Timestamp escrow_signed_time = 17; //contract signed time
	bytes renter_signature = 18; //renter’s signature for the sub contract
	bytes host_signature = 19; //host’s signature from the sub contract
	bytes escrow_signature = 20； //escrow's signature 
	enum State{
		DRAFT = 0; //the contract was draft, but the escrow service did not received the money
		SIGNED = 1;  // the escrow service received the money from renter, the contract was start.
		UPLOADED = 2; //the first challenge was done, which means the shard was in the host, all pending payouts can be issued now
		LOST = 3; // the challenge failed, the following payout should be hold or even stopped
		CANCELED = 4; //if the shard was rebuild after LOST, or after some days of NOQUESTION, it go to CANCELED status
		CLOSED = 5; // the all work in such contract was done
	}
	State state = 21;
	bytes change_log = 22; //TBD one field to store the contract change log, need to discuss whether need the field
	Timestamp last_modify_time = 23;
	bytes guard_signature = 24;
}


message FileStoreMeta{
	bytes renter_address = 1; // buyer wallet address
	bytes file_hash = 2; // file’s hash
	int64 file_size = 3; // file’s size
	Timestamp rent_start = 4; //rent start time
	Timestamp rent_end = 5; //rent end time
	int check_frequence = 6; // shard check frequence in a year,  1 means check once per year
	int64 guard_fee= 7; // reserve: the fee which guard will charge for supporting 
	int64 escrow_fee = 8; //reserve: the fee which escrow will charge for supporting
	int shard_count = 9; //shard's count, by default is 30
	int minimum_shards = 10; //minimum count of shards which can recover the whole file, by default is 10
	int recover_threshold = 11; //reserved field, indicate the threshold for starting to recover
	repeated Contract Contracts = 12;
	bytes escrow_address = 13;
	bytes guard_address = 14;
	bytes renter_signature = 15; //renter's signature for above information
	Timestamp guard_receive_time = 16; //guard received time, which used to calculate the timeout for cancel
	bytes change_log = 17; //TBD one field to store the contract change log, need to discuss whether need the field
	Timestamp last_modify_time = 18;
	bytes guard_signature = 19;
	//TBD need to add one more field for status? 
}

message ChanllengeQuestion{
	bytes shard_hash = 1 //shard hash 
	bytes host_address = 2 //host's address
	int chunk_index = 3 //the chunk's index for calculation
	int random_nounce = 4 //the challenge questions's random nounce 
	bytes expect_answer = 5 //the challenge expected answer
}

message ProofOfReplicateChallenge{
	ChanllengeQuestion question = 1; //of course expect_answer should be clear before send to the host`
	Timestamp challenge_time = 2 //challenge time from guard
	bytes guard_address = 3 //guar's address
	bytes guard_signature = 4 //guard signed for the challenge
	bytes host_answer = 5 //challenge answer
	Timestamp host_sign_time = 6 //response time from host
	bytes host_signature = 7
}


message ChallengeQuestions{
	bytes file_hash = 1; //file's hash
	bytes shard_hash = 2;
	bytes preparer_address = 3 ; //challenge questions preparer's address, it is renter address at phase 1
	int request_count = 4;
	repeated ChanllengeQuestion = 5;
	Timestamp prepare_time = 6;
	bytes renter_signature = 7;
}

message CheckFileStoreMetaRequest{
	bytes file_hash = 1;
	bytes renter_address = 2;
	bytes requester_address = 3;
	bytes signature =4; //requester signed 
}

message Result {
    enum response_code {
      SUCCESS = 0;
      SIGNATURE_FORMAT_ERROR = 1;
      COMPUTE_ADDRESS_ERROR = 2;
      OTHER_ERROR = 20;
    }
    response_code code = 1;
    string message = 2;
}

message HealthStatus{ //TBD if we have another defined object for it, use that object
	bytes peerID =1 //guard’s peer ID
	bytes guard_address = 2 //guard’s pub key/address
	enum status{
		WRONG = 0;
		RUNNING = 1;
		BOOTSTRAP = 2; //reserve 
		PARTIAL_STOP = 3; //reserve field, some function cannot work
	}
	status Status = 3 //current status , running, starting, partial stop
	Timestamp now =4 //current time of guard
	Bytes Signature =5 //signature
}

// message StartEscrowRequest{
// 	ProofOfFund escrow_amount = 1; // the proof of renter had reserve money in the escrow for such shard 
// 	ProofOfFund escrow_collateral_amount = 2; //the proof of host for collateral
// 	enum TokenType{
// 		BTT = 0; 
//     }
// 	TokenType token_type = 3; // token type enum
// 	enum Schedule{
		
//     	WEEK = 2;
//     	MONTH = 3;
// 	}
//     Schedule payout_schedule = 4; // schedule enum
//    	int32 num_payouts = 5; // numbers of payouts
// 	bytes peerId = 6; //reserve: guard's instance's peerId
// 	bytes signature = 7; 
// }

// message changeEscrowRequest{
// 	bytes escrow_id =1;
// 	bytes admin_address =2;
// 	enum RequestType{
// 		NOCHANGE = 0;
// 		STARTPAY = 1;
// 		PAYSINCENOW = 2;
// 		FREEZE = 3; //reserved
// 		STOP = 4;
// 	}
// 	RequestType RequestType = 3;
// 	Timestamp request_sign_time = 4;
// 	bytes signature = 5; 
// }

// message StopEscrowRequest{
// 	bytes escrow_id =1;
// 	bytes admin_address =2;
// 	Timestamp stop_sign_time = 3;
// 	bytes signature = 4; 
// }

// message PaymentStatus{ 
// 	//fields need by guard for escrow payment's staus, need ESCROW decision and revise
// 	bytes from_address = 1; //the fund's original address, in BTFS it should be renter_address
// 	bytes to_address = 2; //the fund's target wallet address, in BTFS it should be host's address
// 	bytes manager_address = 3; //the manager's wallet address, in BTFS it should be guard's address
// 	enum status{
// 		NOTSTART = 0;
// 		RUNNING = 1;
// 		PAUSE = 2;
// 		DONE = 3;
// 	}
// 	status status = 4;
// 	bytes escrow_id = 5; //escrow assigned id for the payment
// 	int64 total_amount = 6; //whole amount of the subcontract , equal rent amount + collateral amount
// 	int64 collateral_amount = 7;
// 	int64 withhold_amount = 8;
// 	int64 paid_amount = 9;
// 	int64 next_payment_amount = 10;
// 	Timestamp next_payment_time = 11;
// 	Timestamp last_payment_time = 12;
// 	Timestamp status_time = 13;
// 	bytes signature = 14;
// }


