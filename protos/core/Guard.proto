syntax = "proto3";



package btfs;



service GuardService{
	rpc submitFileStoreMeta(FileStoreStatus) returns (Result){}
	rpc health() returns(HealthStatus){} //used for other nodes check guard health , TBD input argument discuss with Weiyu & Jin
  	rpc sendQuestions(Questions) returns(Result){} //used for renter send the questions to guard
  	rpc checkFileStoreMeta(CheckFileStoreMetaRequest) returns (FileStoreStatus){} //reserved for other nodes to check contract status
}

//below rpc is needed for host by concept, and it work as BTFS
// service HostService{
// 	rpc challenge(ProofOfReplicateChallenge) returns (ProofOfReplicateChallenge){} //used for receieve challenge question and return the answer, TBD seems can be removed as the BTFS has embed function , no need for service
// 	rpc cancelContract(Contract) returns (Result){}  //removed for phase 2
// }

//the relationship of the objects from Guard's view
// FileStoreMeta (1:n) Contract (1:n) payout
//contract is the signed document between the renter and host for one shard's storage
// the contract information contains buyer, seller, escrow, guard , storage shard's information, rent duration, amount, payment method(periodically and times)
//ContractMeta is the information which will not be changed after proposal
//Contract technically is the contract execution record, it contains the contractMeta and state information
message ContractMeta{ //Contract proposed by renter, will not be changed after renter proposed
	bytes contract_id = 1; //one id which generated by renter, and will be check unique by escrow service
	bytes renter_address = 2; //renter's wallet address
	bytes host_address = 3; //host’s wallet address
	bytes shard_hash = 4; //shard’s hash
	int shard_index = 5; //shard’s sequence of the original file
	int64 shard_file_size = 6; //shard’s file size
	bytes file_hash = 7; //original file's hash, reserved point back to FileStoreMeta
	Timestamp rent_start = 8; //rent start time
	Timestamp rent_end = 9 ; //rent end time
	bytes guard_address = 10; //renter proposed guard's address
	bytes escrow_address = 11; //renter proposed escrow's address
	int64 price = 12; //the price which agreed by host and rental, on the first phase, it equal to the proposed_price
	int64 amount = 13; //the amount which agreed by host and rental, on the first phase, it should be equal file_size*duration*agreed_price
	int64 collaeteral_amount = 14; 
	enum Schedule{		
    	MONTHLY = 0;
    	QUARTERLY = 1;
    	ANNUALLY = 2;
	}
    Schedule payout_schedule = 14; // schedule for payouts
   	int32 num_payouts = 15; // numbers of payouts
}

message Contract{ //the contract executor record, changed frequently after proposal
	Contract contract = 1;
	enum ContractState{
		DRAFT = 0; //the contract was draft, but the escrow service did not received the money
		SIGNED = 1;  // the escrow service received the money from renter, the contract was start.
		UPLOADED = 2; //the first challenge was done, which means the shard was in the host, all pending payouts can be issued now
		LOST = 3; // the challenge failed, the following payout should be hold or even stopped
		CANCELED = 4; //if the shard was rebuild after LOST, or after some days of NOQUESTION, it go to CANCELED status
		CLOSED = 5; // the all work in such contract was done
	}
	State ContractState = 2;
	bytes renter_signature = 3; //renter’s signature for the sub contract
	bytes host_signature = 4; //host’s signature from the sub contract
	Timestamp escrow_signed_time = 5; //contract signed time
	bytes escrow_signature = 6； //escrow's signature 
	repeated log change_log = 7; //TBD one field to store the contract change log, need to discuss whether need the field
	Timestamp last_modify_time = 8;
	bytes guard_signature = 9;
}

message log{
	Timestamp changeTime =1;
	bytes change_originator = 2;
	bytes change = 3;
}

message FileStoreMeta{ //file store meta prepared by renter, will not changed after proposal
	bytes renter_address = 1; // buyer wallet address
	bytes file_hash = 2; // file’s hash
	int64 file_size = 3; // file’s size
	Timestamp rent_start = 4; //rent start time
	Timestamp rent_end = 5; //rent end time
	int check_frequence = 6; // shard check frequence in a year,  1 means check once per year
	int64 guard_fee= 7; // reserve: the fee which guard will charge for supporting 
	int64 escrow_fee = 8; //reserve: the fee which escrow will charge for supporting
	int shard_count = 9; //shard's count, by default is 30
	int minimum_shards = 10; //minimum count of shards which can recover the whole file, by default is 10
	int recover_threshold = 11; //reserved field, indicate the threshold for starting to recover
	bytes escrow_address = 12;
	bytes guard_address = 13;
}

message FileStoreStatus{
	FileStoreMeta FileStoreMeta = 1;
	enum MetaState{
		DRAFT = 0; //the proposal was submit by renter
		UPLOADING = 1; //all related contracts were signed, and renter is uploading shards and questions
		RUNNING = 2; //guard complete the first challenge for all shards
		PARTIAL_LOST = 3; //some shards were lost, but the whole file is safe
		LOST = 4; //some shards were lost and the whole file cannot be recovered now
		DONE = 5; //all contracts were done
	}
	MetaState state = 2;
	repeated Contract Contracts = 3;
	bytes renter_signature = 4; //renter's signature for FileStoreMeta and all contractMeta
	Timestamp guard_receive_time = 5; //guard received time, which used to calculate the timeout for cancel
	repeated log change_log = 6;
	bytes guard_signature = 7;
}	

message ChanllengeQuestion{
	bytes shard_hash = 1 //shard hash 
	bytes host_address = 2 //host's address
	int chunk_index = 3 //the chunk's index for calculation
	int random_nounce = 4 //the challenge questions's random nounce 
	bytes expect_answer = 5 //the challenge expected answer
}

message ProofOfReplicateChallenge{
	ChanllengeQuestion question = 1; //of course expect_answer should be clear before send to the host`
	Timestamp challenge_time = 2 //challenge time from guard
	bytes guard_address = 3 //guar's address
	bytes guard_signature = 4 //guard signed for the challenge
	bytes host_answer = 5 //challenge answer
	Timestamp host_sign_time = 6 //response time from host
	bytes host_signature = 7
}


message ChallengeQuestions{
	bytes file_hash = 1; //file's hash
	bytes shard_hash = 2;
	bytes preparer_address = 3 ; //challenge questions preparer's address, it is renter address at phase 1
	int request_count = 4;
	repeated ChanllengeQuestion = 5;
	Timestamp prepare_time = 6;
	bytes renter_signature = 7;
}

message CheckFileStoreMetaRequest{
	bytes file_hash = 1;
	bytes renter_address = 2;
	bytes requester_address = 3;
	bytes signature =4; //requester signed 
}

message Result {
    enum response_code {
      SUCCESS = 0;
      SIGNATURE_FORMAT_ERROR = 1;
      COMPUTE_ADDRESS_ERROR = 2;
      OTHER_ERROR = 20;
    }
    response_code code = 1;
    string message = 2;
}

message HealthStatus{ 
	bytes peerID =1 // peer ID
	bytes address = 2 // pub key/address
	enum status{
		WRONG = 0;
		RUNNING = 1;
		BOOTSTRAP = 2; //reserve 
		PARTIAL_STOP = 3; //reserve field, some function cannot work
	}
	status status = 3 //current status , running, starting, partial stop
	Timestamp now =4 //current time of guard
	Timestamp start_time = 5
	bytes git_hash = 6 //the git hash of the build related the git repository's branch  
	bytes version = 7 //version we defined for current node
	Bytes signature = 8 //signature
}




